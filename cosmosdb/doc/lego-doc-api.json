[
    {
        "text": "### App\n\nThe `app` module is used communicate between hub and app\n\n#### Sub Modules\n\n#### Bargraph\n\nThe `bargraph` module is used make bar graphs in the SPIKE App\n\nTo use the `bargraph` module simply import the module like so:\n\n```\nfrom app import bargraph\n```\n\n`bargraph` details\n\n##### Functions\n\n##### change\n\nchange(color: int, value: float) -> None\n\n###### Parameters\n\n- - -\n\n###### color: int\n\nA color from the `color` module\n\n###### value: float\n\nThe value\n\n##### clear_all\n\nclear_all() -> None\n\n###### Parameters\n\n- - -\n\n##### get_value\n\nget_value(color: int) -> Awaitable\n\n###### Parameters\n\n- - -\n\n###### color: int\n\nA color from the `color` module\n\n##### hide\n\nhide() -> None\n\n###### Parameters\n\n- - -\n\n##### set_value\n\nset_value(color: int, value: float) -> None\n\n###### Parameters\n\n- - -\n\n###### color: int\n\nA color from the `color` module\n\n###### value: float\n\nThe value\n\n##### show\n\nshow(fullscreen: bool) -> None\n\n###### Parameters\n\n- - -\n\n###### fullscreen: bool\n\nShow in full screen\n\n#### Display\n\nThe `display` module is used show images in the SPIKE App\n\nTo use the `display` module simply import the module like so:\n\n```\nfrom app import display\n```\n\n`display` details\n\n##### Functions\n\n##### hide\n\nhide() -> None\n\n###### Parameters\n\n- - -\n\n##### image\n\nimage(image: int) -> None\n\n###### Parameters\n\n- - -\n\n###### image: int\n\nThe id of the image to show. The range of available images is 1 to 21. There are consts on the `display` module for these\n\n##### show\n\nshow(fullscreen: bool) -> None\n\n###### Parameters\n\n- - -\n\n###### fullscreen: bool\n\nShow in full screen\n\n##### text\n\ntext(text: str) -> None\n\n###### Parameters\n\n- - -\n\n###### text: str\n\nThe text to display\n\n##### Constants\n\n- - -\n\n##### app.display Constants\n\n**IMAGE_ROBOT_1** = 1\n\n**IMAGE_ROBOT_2** = 2\n\n**IMAGE_ROBOT_3** = 3\n\n**IMAGE_ROBOT_4** = 4\n\n**IMAGE_ROBOT_5** = 5\n\n**IMAGE_HUB_1** = 6\n\n**IMAGE_HUB_2** = 7\n\n**IMAGE_HUB_3** = 8\n\n**IMAGE_HUB_4** = 9\n\n**IMAGE_AMUSEMENT_PARK** = 10\n\n**IMAGE_BEACH** = 11\n\n**IMAGE_HAUNTED_HOUSE** = 12\n\n**IMAGE_CARNIVAL** = 13\n\n**IMAGE_BOOKSHELF** = 14\n\n**IMAGE_PLAYGROUND** = 15\n\n**IMAGE_MOON** = 16\n\n**IMAGE_CAVE** = 17\n\n**IMAGE_OCEAN** = 18\n\n**IMAGE_POLAR_BEAR** = 19\n\n**IMAGE_PARK** = 20\n\n**IMAGE_RANDOM** = 21\n\n#### Linegraph\n\nThe `linegraph` module is used make line graphs in the SPIKE App\n\nTo use the `linegraph` module simply import the module like so:\n\n```\nfrom app import linegraph\n```\n\n`linegraph` details\n\n##### Functions\n\n##### clear\n\nclear(color: int) -> None\n\n###### Parameters\n\n- - -\n\n###### color: int\n\nA color from the `color` module\n\n##### clear_all\n\nclear_all() -> None\n\n###### Parameters\n\n- - -\n\n##### get_average\n\nget_average(color: int) -> Awaitable\n\n###### Parameters\n\n- - -\n\n###### color: int\n\nA color from the `color` module\n\n##### get_last\n\nget_last(color: int) -> Awaitable\n\n###### Parameters\n\n- - -\n\n###### color: int\n\nA color from the `color` module\n\n##### get_max\n\nget_max(color: int) -> Awaitable\n\n###### Parameters\n\n- - -\n\n###### color: int\n\nA color from the `color` module\n\n##### get_min\n\nget_min(color: int) -> Awaitable\n\n###### Parameters\n\n- - -\n\n###### color: int\n\nA color from the `color` module\n\n##### hide\n\nhide() -> None\n\n###### Parameters\n\n- - -\n\n##### plot\n\nplot(color: int, x: float, y: float) -> None\n\n###### Parameters\n\n- - -\n\n###### color: int\n\nA color from the `color` module\n\n###### x: float\n\nThe X value\n\n###### y: float\n\nThe Y value\n\n##### show\n\nshow(fullscreen: bool) -> None\n\n###### Parameters\n\n- - -\n\n###### fullscreen: bool\n\nShow in full screen\n\n#### Music\n\nThe `music` module is used make music in the SPIKE App\n\nTo use the `music` module simply import the module like so:\n\n```\nfrom app import music\n```\n\n`music` details\n\n##### Functions\n\n##### play_drum\n\nplay_drum(drum: int) -> None\n\n###### Parameters\n\n- - -\n\n###### drum: int\n\nThe drum name. See all available values in the app.sound module.\n\n##### play_instrument\n\nplay_instrument(instrument: int, note: int, duration: int) -> None\n\n###### Parameters\n\n- - -\n\n###### instrument: int\n\nThe instrument name. See all available values in the app.music module.\n\n###### note: int\n\nThe midi note to play (0-130)\n\n###### duration: int\n\nThe duration in milliseconds\n\n##### Constants\n\n- - -\n\n##### app.music Constants\n\n**DRUM_BASS** = 2\n\n**DRUM_BONGO** = 13\n\n**DRUM_CABASA** = 15\n\n**DRUM_CLAVES** = 9\n\n**DRUM_CLOSED_HI_HAT** = 6\n\n**DRUM_CONGA** = 14\n\n**DRUM_COWBELL** = 11\n\n**DRUM_CRASH_CYMBAL** = 4\n\n**DRUM_CUICA** = 18\n\n**DRUM_GUIRO** = 16\n\n**DRUM_HAND_CLAP** = 8\n\n**DRUM_OPEN_HI_HAT** = 5\n\n**DRUM_SIDE_STICK** = 3\n\n**DRUM_SNARE** = 1\n\n**DRUM_TAMBOURINE** = 7\n\n**DRUM_TRIANGLE** = 12\n\n**DRUM_VIBRASLAP** = 17\n\n**DRUM_WOOD_BLOCK** = 10\n\n**INSTRUMENT_BASS** = 6\n\n**INSTRUMENT_BASSOON** = 14\n\n**INSTRUMENT_CELLO** = 8\n\n**INSTRUMENT_CHOIR** = 15\n\n**INSTRUMENT_CLARINET** = 10\n\n**INSTRUMENT_ELECTRIC_GUITAR** = 5\n\n**INSTRUMENT_ELECTRIC_PIANO** = 2\n\n**INSTRUMENT_FLUTE** = 12\n\n**INSTRUMENT_GUITAR** = 4\n\n**INSTRUMENT_MARIMBA** = 19\n\n**INSTRUMENT_MUSIC_BOX** = 17\n\n**INSTRUMENT_ORGAN** = 3\n\n**INSTRUMENT_PIANO** = 1\n\n**INSTRUMENT_PIZZICATO** = 7\n\n**INSTRUMENT_SAXOPHONE** = 11\n\n**INSTRUMENT_STEEL_DRUM** = 18\n\n**INSTRUMENT_SYNTH_LEAD** = 20\n\n**INSTRUMENT_SYNTH_PAD** = 21\n\n**INSTRUMENT_TROMBONE** = 9\n\n**INSTRUMENT_VIBRAPHONE** = 16\n\n**INSTRUMENT_WOODEN_FLUTE** = 13\n\n#### Sound\n\nThe `sound` module is used play sounds in the SPIKE App\n\nTo use the `sound` module simply import the module like so:\n\n```\nfrom app import sound\n```\n\n`sound` details\n\n##### Functions\n\n##### play\n\nplay(sound_name: str, volume: int = 100, pitch: int = 0, pan: int = 0) -> Awaitable\n\nPlay a sound in the SPIKE App\n\n###### Parameters\n\n- - -\n\n###### sound_name: str\n\nThe sound name as seen in the Word Blocks sound extension\n\n###### volume: int\n\nThe volume (0-100)\n\n###### pitch: int\n\nThe pitch of the sound\n\n###### pan: int\n\nThe pan effect determines which speaker is emitting the sound, with \"-100\" being only the left speaker, \"0\" being normal, and \"100\" being only the right speaker.\n\n##### set_attributes\n\nset_attributes(volume: int, pitch: int, pan: int) -> None\n\n###### Parameters\n\n- - -\n\n###### volume: int\n\nThe volume (0-100)\n\n###### pitch: int\n\nThe pitch of the sound\n\n###### pan: int\n\nThe pan effect determines which speaker is emitting the sound, with \"-100\" being only the left speaker, \"0\" being normal, and \"100\" being only the right speaker.\n\n##### stop\n\nstop() -> None\n\n###### Parameters\n\n- - -\n\n"
    },
    {
        "text": "### Color\n\nThe `color` module contains all the color constants to use with the `color_matrix`, `color_sensor` and `light` modules.\n\nTo use the Color module add the following import statement to your project:\n\n```\nimport color\n```\n\n#### Constants\n\n- - -\n\n#### color Constants\n\n**BLACK** = 0\n\n**MAGENTA** = 1\n\n**PURPLE** = 2\n\n**BLUE** = 3\n\n**AZURE** = 4\n\n**TURQUOISE** = 5\n\n**GREEN** = 6\n\n**YELLOW** = 7\n\n**ORANGE** = 8\n\n**RED** = 9\n\n**WHITE** = 10\n\n**UNKNOWN** = -1\n\n"
    },
    {
        "text": "### Color Matrix\n\nTo use the Color Matrix module add the following import statement to your project:\n\n```\nimport color_matrix\n```\n\nAll functions in the module should be called inside the `color_matrix` module as a prefix like so:\n\n```\ncolor_matrix.set_pixel(port.A, 1, 1, (color.BLUE, 10))\n```\n\n#### Functions\n\n#### clear\n\nclear(port: int) -> None\n\nTurn off all pixels on a Color Matrix\n\n```\nfrom hub import port\nimport color_matrix\n\ncolor_matrix.clear(port.A)\n```\n\n##### Parameters\n\n- - -\n\n##### port: int\n\nA port from the `port` submodule in the `hub` module\n\n#### get_pixel\n\nget_pixel(port: int, x: int, y: int) -> tuple[int, int]\n\nRetrieve a specific pixel represented as a tuple containing the color and intensity\n\n```\nfrom hub import port\nimport color_matrix\n\n# Print the color and intensity of the 0,0 pixel on the Color Matrix connected to port A \nprint(color_matrix.get_pixel(port.A, 0, 0))\n```\n\n##### Parameters\n\n- - -\n\n##### port: int\n\nA port from the `port` submodule in the `hub` module\n\n##### x: int\n\nThe X value (0 - 2)\n\n##### y: int\n\nThe Y value, range (0 - 2)\n\n#### set_pixel\n\nset_pixel(port: int, x: int, y: int, pixel: tuple[color: int, intensity: int]) -> None\n\nChange a single pixel on a Color Matrix\n\n```\nfrom hub import port\nimport color\nimport color_matrix\n\n# Change the color of the 0,0 pixel on the Color Matrix connected to port A \ncolor_matrix.set_pixel(port.A, 0, 0, (color.RED, 10))\n\n# Print the color of the 0,0 pixel on the Color Matrix connected to port A \nprint(color_matrix.get_pixel(port.A, 0, 0)[0])\n```\n\n##### Parameters\n\n- - -\n\n##### port: int\n\nA port from the `port` submodule in the `hub` module\n\n##### x: int\n\nThe X value (0 - 2)\n\n##### y: int\n\nThe Y value, range (0 - 2)\n\n##### pixel: tuple[color: int, intensity: int]\n\nTuple containing color and intensity, meaning how bright to light up the pixel\n\n#### show\n\nshow(port: int, pixels: list[tuple[int, int]]) -> None\n\nChange all pixels at once on a Color Matrix\n\n```\nfrom hub import port\nimport color\nimport color_matrix\n\n# Update all pixels on Color Matrix using the show function \n\n# Create a list with 18 items (color and intensity pairs) \npixels = [(color.BLUE, 10)] * 9 \n\n# Update all pixels to show same color and intensity \ncolor_matrix.show(port.A, pixels)\n```\n\n##### Parameters\n\n- - -\n\n##### port: int\n\nA port from the `port` submodule in the `hub` module\n\n##### pixels: list[tuple[int, int]]\n\nA list containing color and intensity value tuples for all 9 pixels.\n\n"
    },
    {
        "text": "### Color Sensor\n\nThe `color_sensor` module enables you to write code that reacts to specific colors or the intensity of the reflected light.\n\nTo use the Color Sensor module add the following import statement to your project:\n\n```\nimport color_sensor\n```\n\nAll functions in the module should be called inside the `color_sensor` module as a prefix like so:\n\n```\ncolor_sensor.reflection(port.A)\n```\n\nThe Color Sensor can recognize the following colors:\n\nRed  \nGreen  \nBlue  \nMagenta  \nYellow  \nOrange  \nAzure  \nBlack  \nWhite\n\n#### Functions\n\n#### color\n\ncolor(port: int) -> int\n\nReturns the color value of the detected color. Use the `color` module to map the color value to a specific color.\n\n```\nimport color_sensor\nfrom hub import port\nimport color\n\nif color_sensor.color(port.A) is color.RED:\n    print(\"Red detected\")\n```\n\n##### Parameters\n\n- - -\n\n##### port: int\n\nA port from the `port` submodule in the `hub` module\n\n#### reflection\n\nreflection(port: int) -> int\n\nRetrieves the intensity of the reflected light (0-100%).\n\n##### Parameters\n\n- - -\n\n##### port: int\n\nA port from the `port` submodule in the `hub` module\n\n#### rgbi\n\nrgbi(port: int) -> tuple[int, int, int, int]\n\nRetrieves the overall color intensity and intensity of red, green and blue.\n\nReturns tuple[red: int, green: int, blue: int, intensity: int]\n\n##### Parameters\n\n- - -\n\n##### port: int\n\nA port from the `port` submodule in the `hub` module\n\n"
    },
    {
        "text": "### Device\n\nThe `device` module enables you to write code to get information about devices plugged into the hub.\n\nTo use the Device module add the following import statement to your project:\n\n```\nimport device\n```\n\nAll functions in the module should be called inside the `device` module as a prefix like so:\n\n```\ndevice.device_id(port.A)\n```\n\n#### Functions\n\n#### data\n\ndata(port: int) -> tuple[int]\n\nRetrieve the raw LPF-2 data from a device.\n\n##### Parameters\n\n- - -\n\n##### port: int\n\nA port from the `port` submodule in the `hub` module\n\n#### id\n\nid(port: int) -> int\n\nRetrieve the device id of a device. Each device has an id based on its type.\n\n##### Parameters\n\n- - -\n\n##### port: int\n\nA port from the `port` submodule in the `hub` module\n\n#### get_duty_cycle\n\nget_duty_cycle(port: int) -> int\n\nRetrieve the duty cycle for a device. Returned values is in range 0 to 10000\n\n##### Parameters\n\n- - -\n\n##### port: int\n\nA port from the `port` submodule in the `hub` module\n\n#### ready\n\nready(port: int) -> bool\n\nWhen a device is attached to the hub it might take a short amount of time before it's ready to accept requests.  \nUse `ready` to test for the readiness of the attached devices.\n\n##### Parameters\n\n- - -\n\n##### port: int\n\nA port from the `port` submodule in the `hub` module\n\n#### set_duty_cycle\n\nset_duty_cycle(port: int, duty_cycle: int) -> None\n\nSet the duty cycle on a device. Range 0 to 10000\n\n##### Parameters\n\n- - -\n\n##### port: int\n\nA port from the `port` submodule in the `hub` module\n\n##### duty_cycle: int\n\nThe PWM value (0-10000)\n\n"
    },
    {
        "text": "### Distance Sensor\n\nThe `distance_sensor` module enables you to write code that reacts to specific distances or light up the Distance Sensor in different ways.\n\nTo use the Distance Sensor module add the following import statement to your project:\n\n```\nimport distance_sensor\n```\n\nAll functions in the module should be called inside the `distance_sensor` module as a prefix like so:\n\n```\ndistance_sensor.distance(port.A)\n```\n\n#### Functions\n\n#### clear\n\nclear(port: int) -> None\n\nTurns off all the lights in the Distance Sensor connected to `port`.\n\n##### Parameters\n\n- - -\n\n##### port: int\n\nA port from the `port` submodule in the `hub` module\n\n#### distance\n\ndistance(port: int) -> int\n\nRetrieve the distance in millimeters captured by the Distance Sensor connected to `port`. If the Distance Sensor cannot read a valid distance it will return -1.\n\n##### Parameters\n\n- - -\n\n##### port: int\n\nA port from the `port` submodule in the `hub` module\n\n#### get_pixel\n\nget_pixel(port: int, x: int, y: int) -> int\n\nRetrieve the intensity of a specific light on the Distance Sensor connected to `port`.\n\n##### Parameters\n\n- - -\n\n##### port: int\n\nA port from the `port` submodule in the `hub` module\n\n##### x: int\n\nThe X value (0 - 3)\n\n##### y: int\n\nThe Y value, range (0 - 3)\n\n#### set_pixel\n\nset_pixel(port: int, x: int, y: int, intensity: int) -> None\n\nChanges the intensity of a specific light on the Distance Sensor connected to `port`.\n\n##### Parameters\n\n- - -\n\n##### port: int\n\nA port from the `port` submodule in the `hub` module\n\n##### x: int\n\nThe X value (0 - 3)\n\n##### y: int\n\nThe Y value, range (0 - 3)\n\n##### intensity: int\n\nHow bright to light up the pixel\n\n#### show\n\nshow(port: int, pixels: list[int]) -> None\n\nChange all the lights at the same time.\n\n```\nfrom hub import port\nimport distance_sensor\n\n# Update all pixels on Distance Sensor using the show function \n\n# Create a list with 4 identical intensity values \npixels = [100] * 4 \n\n# Update all pixels to show same intensity \ndistance_sensor.show(port.A, pixels)\n```\n\n##### Parameters\n\n- - -\n\n##### port: int\n\nA port from the `port` submodule in the `hub` module\n\n##### pixels: bytes\n\nA list containing intensity values for all 4 pixels.\n\n"
    },
    {
        "text": "### Force Sensor\n\nThe `force_sensor` module contains all functions and constants to use the Force Sensor.\n\nTo use the Force Sensor module add the following import statement to your project:\n\n```\nimport force_sensor\n```\n\nAll functions in the module should be called inside the `force_sensor` module as a prefix like so:\n\n```\nforce_sensor.force(port.A)\n```\n\n#### Functions\n\n#### force\n\nforce(port: int) -> int\n\nRetrieves the measured force as decinewton. Values range from 0 to 100\n\n```\nfrom hub import port\nimport force_sensor\n\n\nprint(force_sensor.force(port.A))\n```\n\n##### Parameters\n\n- - -\n\n##### port: int\n\nA port from the `port` submodule in the `hub` module\n\n#### pressed\n\npressed(port: int) -> bool\n\nTests whether the button on the sensor is pressed. Returns true if the force sensor connected to port is pressed.\n\n```\nfrom hub import port\nimport force_sensor\n\n\nprint(force_sensor.pressed(port.A))\n```\n\n##### Parameters\n\n- - -\n\n##### port: int\n\nA port from the `port` submodule in the `hub` module\n\n#### raw\n\nraw(port: int) -> int\n\nReturns the raw, uncalibrated force value of the force sensor connected on port `port`\n\n```\nfrom hub import port\nimport force_sensor\n\n\nprint(force_sensor.raw(port.A))\n```\n\n##### Parameters\n\n- - -\n\n##### port: int\n\nA port from the `port` submodule in the `hub` module\n\n"
    },
    {
        "text": "### Hub\n\n#### Sub Modules\n\n#### Button\n\nTo use the Button module add the following import statement to your project:\n\n```\nfrom hub import button\n```\n\nAll functions in the module should be called inside the `button` module as a prefix like so:\n\n```\nbutton.pressed(button.LEFT)\n```\n\n##### Functions\n\n##### pressed\n\nint pressed(button: int) -> int\n\nThis module allows you to react to buttons being pressed on the hub. You must first import the `button` module to use the buttons.\n\n```\nfrom hub import button\n\nleft_button_press_duration = 0\n\n# Wait for the left button to be pressed \nwhile not button.pressed(button.LEFT):\n    pass\n\n# As long as the left button is being pressed, update the `left_button_press_duration` variable \nwhile button.pressed(button.LEFT):\n    left_button_press_duration = button.pressed(button.LEFT)\n\nprint(\"Left button was pressed for \" + str(left_button_press_duration) + \" milliseconds\")\n```\n\n###### Parameters\n\n- - -\n\n###### button: int\n\nA button from the `button` submodule in the `hub` module\n\n##### Constants\n\n- - -\n\n##### hub.button Constants\n\n**LEFT** = 1  \nLeft button next to the power button on the SPIKE Prime hub  \n**RIGHT** = 2  \nRight button next to the power button on the SPIKE Prime hub\n\n#### Light\n\nThe `light` module includes functions to change the color of the light on the SPIKE Prime hub.\n\nTo use the Light module add the following import statement to your project:\n\n```\nfrom hub import light\n```\n\nAll functions in the module should be called inside the `light` module as a prefix like so:\n\n```\nlight.color(color.RED)\n```\n\n##### Functions\n\n##### color\n\ncolor(light: int, color: int) -> None\n\nChange the color of a light on the hub.\n\n```\nfrom hub import light\nimport color\n\n# Change the light to red \nlight.color(light.POWER, color.RED)\n```\n\n###### Parameters\n\n- - -\n\n###### light: int\n\nThe light on the hub\n\n###### color: int\n\nA color from the `color` module\n\n##### Constants\n\n- - -\n\n##### hub.light Constants\n\n**POWER** = 0  \nThe power button. On SPIKE Prime it's the button between the left and right buttons.  \n**CONNECT** = 1  \nThe light around the Bluetooth connect button on SPIKE Prime.\n\n#### Light Matrix\n\nTo use the Light Matrix module add the following import statement to your project:\n\n```\nfrom hub import light_matrix\n```\n\nAll functions in the module should be called inside the `light_matrix` module as a prefix like so:\n\n```\nlight_matrix.write(\"Hello World\")\n```\n\n##### Functions\n\n##### clear\n\nclear() -> None\n\nSwitches off all of the pixels on the Light Matrix.\n\n```\nfrom hub import light_matrix\nimport time\n# Update pixels to show an image on Light Matrix, and then turn them off using the clear function \n\n# Show a small heart \nlight_matrix.show_image(2)\n\n# Wait for two seconds \ntime.sleep_ms(2000)\n\n# Switch off the heart \nlight_matrix.clear()\n```\n\n###### Parameters\n\n- - -\n\n##### get_orientation\n\nget_orientation() -> int\n\nRetrieve the current orientation of the Light Matrix.  \nCan be used with the following constants: `orientation.UP`, `orientation.LEFT`, `orientation.RIGHT`, `orientation.DOWN`\n\n###### Parameters\n\n- - -\n\n##### get_pixel\n\nget_pixel(x: int, y: int) -> int\n\nRetrieve the intensity of a specific pixel on the Light Matrix.\n\n```\nfrom hub import light_matrix\n\n# Show a heart \nlight_matrix.show_image(1)\n\n# Print the value of the center pixel's intensity \nprint(light_matrix.get_pixel(2, 2))\n```\n\n###### Parameters\n\n- - -\n\n###### x: int\n\nThe X value, range (0 - 4)\n\n###### y: int\n\nThe Y value, range (0 - 4)\n\n##### set_orientation\n\nset_orientation(top: int) -> int\n\nChange the orientation of the Light Matrix. All subsequent calls will use the new orientation.  \nCan be used with the following constants: `orientation.UP`, `orientation.LEFT`, `orientation.RIGHT`, `orientation.DOWN`\n\n###### Parameters\n\n- - -\n\n###### top: int\n\nThe side of the hub to be the top\n\n##### set_pixel\n\nset_pixel(x: int, y: int, intensity: int) -> None\n\nSets the brightness of one pixel (one of the 25 LEDs) on the Light Matrix.\n\n```\nfrom hub import light_matrix\n# Turn on the pixel in the center of the hub \nlight_matrix.set_pixel(2, 2, 100)\n```\n\n###### Parameters\n\n- - -\n\n###### x: int\n\nThe X value, range (0 - 4)\n\n###### y: int\n\nThe Y value, range (0 - 4)\n\n###### intensity: int\n\nHow bright to light up the pixel\n\n##### show\n\nshow(pixels: list[int]) -> None\n\nChange all the lights at the same time.\n\n```\nfrom hub import light_matrix\n# Update all pixels on Light Matrix using the show function \n\n# Create a list with 25 identical intensity values \npixels = [100] * 25 \n\n# Update all pixels to show same intensity \nlight_matrix.show(pixels)\n```\n\n###### Parameters\n\n- - -\n\n###### pixels: Iterable\n\nA list containing light intensity values for all 25 pixels.\n\n##### show_image\n\nshow_image(image: int) -> None\n\nDisplay one of the built in images on the display.\n\n```\nfrom hub import light_matrix\n# Update pixels to show an image on Light Matrix using the show_image function \n\n# Show a smiling face \nlight_matrix.show_image(light_matrix.IMAGE_HAPPY)\n```\n\n###### Parameters\n\n- - -\n\n###### image: int\n\nThe id of the image to show. The range of available images is 1 to 67. There are consts on the `light_matrix` module for these.\n\n##### write\n\nwrite(text: str, intensity: int = 100, time_per_character: int = 500) -> Awaitable\n\nDisplays text on the Light Matrix, one letter at a time, scrolling from right to left except if there is a single character to show which will not scroll\n\n```\nfrom hub import light_matrix\n# White a message to the hub \nlight_matrix.write(\"Hello, world!\")\n```\n\n###### Parameters\n\n- - -\n\n###### text: str\n\nThe text to display\n\n###### intensity: int\n\nHow bright to light up the pixel\n\n###### time_per_character: int\n\nHow long to show each character on the display\n\n##### Constants\n\n- - -\n\n##### hub.light_matrix Constants\n\n**IMAGE_HEART** = 1\n\n**IMAGE_HEART_SMALL** = 2\n\n**IMAGE_HAPPY** = 3\n\n**IMAGE_SMILE** = 4\n\n**IMAGE_SAD** = 5\n\n**IMAGE_CONFUSED** = 6\n\n**IMAGE_ANGRY** = 7\n\n**IMAGE_ASLEEP** = 8\n\n**IMAGE_SURPRISED** = 9\n\n**IMAGE_SILLY** = 10\n\n**IMAGE_FABULOUS** = 11\n\n**IMAGE_MEH** = 12\n\n**IMAGE_YES** = 13\n\n**IMAGE_NO** = 14\n\n**IMAGE_CLOCK12** = 15\n\n**IMAGE_CLOCK1** = 16\n\n**IMAGE_CLOCK2** = 17\n\n**IMAGE_CLOCK3** = 18\n\n**IMAGE_CLOCK4** = 19\n\n**IMAGE_CLOCK5** = 20\n\n**IMAGE_CLOCK6** = 21\n\n**IMAGE_CLOCK7** = 22\n\n**IMAGE_CLOCK8** = 23\n\n**IMAGE_CLOCK9** = 24\n\n**IMAGE_CLOCK10** = 25\n\n**IMAGE_CLOCK11** = 26\n\n**IMAGE_ARROW_N** = 27\n\n**IMAGE_ARROW_NE** = 28\n\n**IMAGE_ARROW_E** = 29\n\n**IMAGE_ARROW_SE** = 30\n\n**IMAGE_ARROW_S** = 31\n\n**IMAGE_ARROW_SW** = 32\n\n**IMAGE_ARROW_W** = 33\n\n**IMAGE_ARROW_NW** = 34\n\n**IMAGE_GO_RIGHT** = 35\n\n**IMAGE_GO_LEFT** = 36\n\n**IMAGE_GO_UP** = 37\n\n**IMAGE_GO_DOWN** = 38\n\n**IMAGE_TRIANGLE** = 39\n\n**IMAGE_TRIANGLE_LEFT** = 40\n\n**IMAGE_CHESSBOARD** = 41\n\n**IMAGE_DIAMOND** = 42\n\n**IMAGE_DIAMOND_SMALL** = 43\n\n**IMAGE_SQUARE** = 44\n\n**IMAGE_SQUARE_SMALL** = 45\n\n**IMAGE_RABBIT** = 46\n\n**IMAGE_COW** = 47\n\n**IMAGE_MUSIC_CROTCHET** = 48\n\n**IMAGE_MUSIC_QUAVER** = 49\n\n**IMAGE_MUSIC_QUAVERS** = 50\n\n**IMAGE_PITCHFORK** = 51\n\n**IMAGE_XMAS** = 52\n\n**IMAGE_PACMAN** = 53\n\n**IMAGE_TARGET** = 54\n\n**IMAGE_TSHIRT** = 55\n\n**IMAGE_ROLLERSKATE** = 56\n\n**IMAGE_DUCK** = 57\n\n**IMAGE_HOUSE** = 58\n\n**IMAGE_TORTOISE** = 59\n\n**IMAGE_BUTTERFLY** = 60\n\n**IMAGE_STICKFIGURE** = 61\n\n**IMAGE_GHOST** = 62\n\n**IMAGE_SWORD** = 63\n\n**IMAGE_GIRAFFE** = 64\n\n**IMAGE_SKULL** = 65\n\n**IMAGE_UMBRELLA** = 66\n\n**IMAGE_SNAKE** = 67\n\n#### Motion Sensor\n\nTo use the Motion Sensor module add the following import statement to your project:\n\n```\nfrom hub import motion_sensor\n```\n\nAll functions in the module should be called inside the `motion_sensor` module as a prefix like so:\n\n```\nmotion_sensor.up_face()\n```\n\n##### Functions\n\n##### acceleration\n\nacceleration(raw_unfiltered: bool) -> tuple[int, int, int]\n\nReturns a tuple containing x, y & z acceleration values as integers. The values are mili G, so 1 / 1000 G\n\n###### Parameters\n\n- - -\n\n###### raw_unfiltered: bool\n\nIf we want the data back raw and unfiltered\n\n##### angular_velocity\n\nangular_velocity(raw_unfiltered: bool) -> tuple[int, int, int]\n\nReturns a tuple containing x, y & z angular velocity values as integers. The values are decidegrees per second\n\n###### Parameters\n\n- - -\n\n###### raw_unfiltered: bool\n\nIf we want the data back raw and unfiltered\n\n##### gesture\n\ngesture() -> int\n\nReturns the gesture recognized.\n\nPossible values are:\n\n`motion_sensor.TAPPED`  \n`motion_sensor.DOUBLE_TAPPED`  \n`motion_sensor.SHAKEN`  \n`motion_sensor.FALLING`  \n`motion_sensor.UNKNOWN`\n\n###### Parameters\n\n- - -\n\n##### get_yaw_face\n\nget_yaw_face() -> int\n\nRetrieve the face of the hub that yaw is relative to.  \nIf you put the hub on a flat surface with the face returned pointing up, when you rotate the hub only the yaw will update  \n`motion_sensor.TOP` The SPIKE Prime hub face with the USB charging port.  \n`motion_sensor.FRONT` The SPIKE Prime hub face with the Light Matrix.  \n`motion_sensor.RIGHT` The right side of the SPIKE Prime hub when facing the front hub face.  \n`motion_sensor.BOTTOM` The side of the SPIKE Prime hub where the battery is.  \n`motion_sensor.BACK` The SPIKE Prime hub face where the speaker is.  \n`motion_sensor.LEFT` The left side of the SPIKE Prime hub when facing the front hub face.\n\n###### Parameters\n\n- - -\n\n##### quaternion\n\nquaternion() -> tuple[float, float, float, float]\n\nReturns the hub orientation quaternion as a tuple[w: float, x: float, y: float, z: float].\n\n###### Parameters\n\n- - -\n\n##### reset_tap_count\n\nreset_tap_count() -> None\n\nReset the tap count returned by the `tap_count` function\n\n###### Parameters\n\n- - -\n\n##### reset_yaw\n\nreset_yaw(angle: int) -> None\n\nChange the yaw angle offset.  \nThe angle set will be the new yaw value.\n\n###### Parameters\n\n- - -\n\n###### angle: int\n\n##### set_yaw_face\n\nset_yaw_face(up: int) -> bool\n\nChange what hub face is used as the yaw face.If you put the hub on a flat surface with this face pointing up, when you rotate the hub only the yaw will update\n\n###### Parameters\n\n- - -\n\n###### up: int\n\nThe hub face that should be set as the upwards facing hub face.  \nAvailable values are:\n\n`motion_sensor.TOP` The SPIKE Prime hub face with the USB charging port.  \n`motion_sensor.FRONT` The SPIKE Prime hub face with the Light Matrix.  \n`motion_sensor.RIGHT` The right side of the SPIKE Prime hub when facing the front hub face.  \n`motion_sensor.BOTTOM` The side of the SPIKE Prime hub where the battery is.  \n`motion_sensor.BACK` The SPIKE Prime hub face where the speaker is.  \n`motion_sensor.LEFT` The left side of the SPIKE Prime hub when facing the front hub face.\n\n##### stable\n\nstable() -> bool\n\nWhether or not the hub is resting flat.\n\n###### Parameters\n\n- - -\n\n##### tap_count\n\ntap_count() -> int\n\nReturns the number of taps recognized since the program started or last time `motion_sensor.reset_tap_count()` was called.\n\n###### Parameters\n\n- - -\n\n##### tilt_angles\n\ntilt_angles() -> tuple[int, int, int]\n\nReturns a tuple containing yaw pitch and roll values as integers. Values are decidegrees\n\n###### Parameters\n\n- - -\n\n##### up_face\n\nup_face() -> int\n\nReturns the Hub face that is currently facing up  \n`motion_sensor.TOP` The SPIKE Prime hub face with the USB charging port.  \n`motion_sensor.FRONT` The SPIKE Prime hub face with the Light Matrix.  \n`motion_sensor.RIGHT` The right side of the SPIKE Prime hub when facing the front hub face.  \n`motion_sensor.BOTTOM` The side of the SPIKE Prime hub where the battery is.  \n`motion_sensor.BACK` The SPIKE Prime hub face where the speaker is.  \n`motion_sensor.LEFT` The left side of the SPIKE Prime hub when facing the front hub face.\n\n###### Parameters\n\n- - -\n\n##### Constants\n\n- - -\n\n##### hub.motion_sensor Constants\n\n**TAPPED** = 0\n\n**DOUBLE_TAPPED** = 1\n\n**SHAKEN** = 2\n\n**FALLING** = 3\n\n**UNKNOWN** = -1\n\n**TOP** = 0  \nThe SPIKE Prime hub face with the Light Matrix.  \n**FRONT** = 1  \nThe SPIKE Prime hub face where the speaker is.  \n**RIGHT** = 2  \nThe right side of the SPIKE Prime hub when facing the front hub face.  \n**BOTTOM** = 3  \nThe side of the SPIKE Prime hub where the battery is.  \n**BACK** = 4  \nThe SPIKE Prime hub face with the USB charging port.  \n**LEFT** = 5  \nThe left side of the SPIKE Prime hub when facing the front hub face.\n\n#### Port\n\nThis module contains constants that enables easy access to the ports on the SPIKE Prime hub. Use the constants in all functions that takes a `port` parameter.\n\nTo use the Port module add the following import statement to your project:\n\n```\nfrom hub import port\n```\n\nAll functions in the module should be called inside the `port` module as a prefix like so:\n\n```\nport.A\n```\n\n##### Constants\n\n- - -\n\n##### hub.port Constants\n\n**A** = 0  \nThe Port that is labelled ‘A’ on the Hub.  \n**B** = 1  \nThe Port that is labelled ‘B’ on the Hub.  \n**C** = 2  \nThe Port that is labelled ‘C’ on the Hub.  \n**D** = 3  \nThe Port that is labelled ‘D’ on the Hub.  \n**E** = 4  \nThe Port that is labelled ‘E’ on the Hub.  \n**F** = 5  \nThe Port that is labelled ‘F’ on the Hub.\n\n#### Sound\n\nTo use the Sound module add the following import statement to your project:\n\n```\nfrom hub import sound\n```\n\nAll functions in the module should be called inside the `sound` module as a prefix like so:\n\n```\nsound.stop()\n```\n\n##### Functions\n\n##### beep\n\nbeep(freq: int = 440, duration: int = 500, volume: int = 100, *, attack: int = 0, decay: int = 0, sustain: int = 100, release: int = 0, transition: int = 10, waveform: int = WAVEFORM_SINE, channel: int = DEFAULT) -> Awaitable\n\nPlays a beep sound from the hub\n\n###### Parameters\n\n- - -\n\n###### freq: int\n\nThe frequency to play\n\n###### duration: int\n\nThe duration in milliseconds\n\n###### volume: int\n\nThe volume (0-100)\n\n###### Optional keyword arguments:\n\n###### attack: int\n\nThe time taken for initial run-up of level from nil to peak, beginning when the key is pressed.\n\n###### decay: int\n\nThe time taken for the subsequent run down from the attack level to the designated sustain level.\n\n###### sustain: int\n\nThe level during the main sequence of the sound's duration, until the key is released.\n\n###### release: int\n\nThe time taken for the level to decay from the sustain level to zero after the key is released\n\n###### transition: int\n\ntime in milliseconds to transition into the sound if something is already playing in the channel\n\n###### waveform: int\n\nThe synthesized waveform. Use one of the constants in the `hub.sound` module.\n\n###### channel: int\n\nThe desired channel to play on, options are `sound.DEFAULT` and `sound.ANY`\n\n##### stop\n\nstop() -> None\n\nStops all noise from the hub\n\n###### Parameters\n\n- - -\n\n##### volume\n\nvolume(volume: int) -> None\n\n###### Parameters\n\n- - -\n\n###### volume: int\n\nThe volume (0-100)\n\n##### Constants\n\n- - -\n\n##### hub.sound Constants\n\n**ANY** = -2\n\n**DEFAULT** = -1\n\n**WAVEFORM_SINE** = 1\n\n**WAVEFORM_SAWTOOTH** = 3\n\n**WAVEFORM_SQUARE** = 2\n\n**WAVEFORM_TRIANGLE** = 1\n\n#### Functions\n\n#### device_uuid\n\ndevice_uuid() -> str\n\nRetrieve the device id.\n\n##### Parameters\n\n- - -\n\n#### hardware_id\n\nhardware_id() -> str\n\nRetrieve the hardware id.\n\n##### Parameters\n\n- - -\n\n#### power_off\n\npower_off() -> int\n\nTurns off the hub.\n\n##### Parameters\n\n- - -\n\n#### temperature\n\ntemperature() -> int\n\nRetrieve the hub temperature. Measured in decidegrees celsius (d°C) which is 1 / 10 of a degree celsius (°C)\n\n##### Parameters\n\n- - -\n\n"
    },
    {
        "text": "### Motor\n\nTo use a Motor add the following import statement to your project:\n\n```\nimport motor\n```\n\nAll functions in the module should be called inside the `motor` module as a prefix like so:\n\n```\nmotor.run(port.A, 1000)\n```\n\n#### Functions\n\n#### absolute_position\n\nabsolute_position(port: int) -> int\n\nGet the absolute position of a Motor\n\n##### Parameters\n\n- - -\n\n##### port: int\n\nA port from the `port` submodule in the `hub` module\n\n#### get_duty_cycle\n\nget_duty_cycle(port: int) -> int\n\nGet the pwm of a Motor\n\n##### Parameters\n\n- - -\n\n##### port: int\n\nA port from the `port` submodule in the `hub` module\n\n#### relative_position\n\nrelative_position(port: int) -> int\n\nGet the relative position of a Motor\n\n##### Parameters\n\n- - -\n\n##### port: int\n\nA port from the `port` submodule in the `hub` module\n\n#### reset_relative_position\n\nreset_relative_position(port: int, position: int) -> None\n\nChange the position used as the offset when using the `run_to_relative_position` function.\n\n##### Parameters\n\n- - -\n\n##### port: int\n\nA port from the `port` submodule in the `hub` module\n\n##### position: int\n\nThe degree of the motor\n\n#### run\n\nrun(port: int, velocity: int, *, acceleration: int = 1000) -> None\n\nStart a Motor at a constant speed\n\n```\nfrom hub import port\nimport motor, time\n\n# Start motor \nmotor.run(port.A, 1000)\n```\n\n##### Parameters\n\n- - -\n\n##### port: int\n\nA port from the `port` submodule in the `hub` module\n\n##### velocity: int\n\nThe velocity in degrees/sec\n\nValue ranges depends on motor type.\n\nSmall motor (essential): -660 to 660  \nMedium motor: -1110 to 1110  \nLarge motor: -1050 to 1050\n\n##### Optional keyword arguments:\n\n##### acceleration: int\n\nThe acceleration (deg/sec²) (1 - 10000)\n\n#### run_for_degrees\n\nrun_for_degrees(port: int, degrees: int, velocity: int, *, stop: int = BRAKE, acceleration: int = 1000, deceleration: int = 1000) -> Awaitable\n\nTurn a motor for a specific number of degrees  \nWhen awaited returns a status of the movement that corresponds to one of the following constants:\n\n`motor.READY`  \n`motor.RUNNING`  \n`motor.STALLED`  \n`motor.CANCELED`  \n`motor.ERROR`  \n`motor.DISCONNECTED`\n\n##### Parameters\n\n- - -\n\n##### port: int\n\nA port from the `port` submodule in the `hub` module\n\n##### degrees: int\n\nThe number of degrees\n\n##### velocity: int\n\nThe velocity in degrees/sec\n\nValue ranges depends on motor type.\n\nSmall motor (essential): -660 to 660  \nMedium motor: -1110 to 1110  \nLarge motor: -1050 to 1050\n\n##### Optional keyword arguments:\n\n##### stop: int\n\nThe behavior of the Motor after it has stopped. Use the constants in the `motor` module.\n\nPossible values are  \n`motor.COAST` to make the motor coast until a stop  \n`motor.BREAK` to brake and continue to brake after stop  \n`motor.HOLD` to tell the motor to hold it's position  \n`motor.CONTINUE` to tell the motor to keep running at whatever velocity it's running at until it gets another command  \n`motor.SMART_COAST` to make the motor brake until stop and then coast and compensate for inaccuracies in the next command  \n`motor.SMART_BRAKE` to make the motor brake and continue to brake after stop and compensate for inaccuracies in the next command\n\n##### acceleration: int\n\nThe acceleration (deg/sec²) (1 - 10000)\n\n##### deceleration: int\n\nThe deceleration (deg/sec²) (1 - 10000)\n\n#### run_for_time\n\nrun_for_time(port: int, duration: int, velocity: int, *, stop: int = BRAKE, acceleration: int = 1000, deceleration: int = 1000) -> Awaitable\n\nRun a Motor for a limited amount of time  \nWhen awaited returns a status of the movement that corresponds to one of the following constants:\n\n`motor.READY`  \n`motor.RUNNING`  \n`motor.STALLED`  \n`motor.ERROR`  \n`motor.DISCONNECTED`\n\n```\nfrom hub import port\nimport runloop\nimport motor\n\nasync def main():\n    # Run at 1000 velocity for 1 second \n    await motor.run_for_time(port.A, 1000, 1000)\n\n    # Run at 280 velocity for 1 second \n    await motor_pair.run_for_time(port.A, 1000, 280)\n\n    # Run at 280 velocity for 10 seconds with a slow deceleration \n    await motor_pair.run_for_time(port.A, 10000, 280, deceleration=10)\n\nrunloop.run(main())\n```\n\n##### Parameters\n\n- - -\n\n##### port: int\n\nA port from the `port` submodule in the `hub` module\n\n##### duration: int\n\nThe duration in milliseconds\n\n##### velocity: int\n\nThe velocity in degrees/sec\n\nValue ranges depends on motor type.\n\nSmall motor (essential): -660 to 660  \nMedium motor: -1110 to 1110  \nLarge motor: -1050 to 1050\n\n##### Optional keyword arguments:\n\n##### stop: int\n\nThe behavior of the Motor after it has stopped. Use the constants in the `motor` module.\n\nPossible values are  \n`motor.COAST` to make the motor coast until a stop  \n`motor.BREAK` to brake and continue to brake after stop  \n`motor.HOLD` to tell the motor to hold it's position  \n`motor.CONTINUE` to tell the motor to keep running at whatever velocity it's running at until it gets another command  \n`motor.SMART_COAST` to make the motor brake until stop and then coast and compensate for inaccuracies in the next command  \n`motor.SMART_BRAKE` to make the motor brake and continue to brake after stop and compensate for inaccuracies in the next command\n\n##### acceleration: int\n\nThe acceleration (deg/sec²) (1 - 10000)\n\n##### deceleration: int\n\nThe deceleration (deg/sec²) (1 - 10000)\n\n#### run_to_absolute_position\n\nrun_to_absolute_position(port: int, position: int, velocity: int, *, direction: int = motor.SHORTEST_PATH, stop: int = BRAKE, acceleration: int = 1000, deceleration: int = 1000) -> Awaitable\n\nTurn a motor to an absolute position.  \nWhen awaited returns a status of the movement that corresponds to one of the following constants:\n\n`motor.READY`  \n`motor.RUNNING`  \n`motor.STALLED`  \n`motor.CANCELED`  \n`motor.ERROR`  \n`motor.DISCONNECTED`\n\n##### Parameters\n\n- - -\n\n##### port: int\n\nA port from the `port` submodule in the `hub` module\n\n##### position: int\n\nThe degree of the motor\n\n##### velocity: int\n\nThe velocity in degrees/sec\n\nValue ranges depends on motor type.\n\nSmall motor (essential): -660 to 660  \nMedium motor: -1110 to 1110  \nLarge motor: -1050 to 1050\n\n##### Optional keyword arguments:\n\n##### direction: int\n\nThe direction to turn.  \nOptions are:\n\n`motor.CLOCKWISE`  \n`motor.COUNTERCLOCKWISE`  \n`motor.SHORTEST_PATH`  \n`motor.LONGEST_PATH`\n\n##### stop: int\n\nThe behavior of the Motor after it has stopped. Use the constants in the `motor` module.\n\nPossible values are  \n`motor.COAST` to make the motor coast until a stop  \n`motor.BREAK` to brake and continue to brake after stop  \n`motor.HOLD` to tell the motor to hold it's position  \n`motor.CONTINUE` to tell the motor to keep running at whatever velocity it's running at until it gets another command  \n`motor.SMART_COAST` to make the motor brake until stop and then coast and compensate for inaccuracies in the next command  \n`motor.SMART_BRAKE` to make the motor brake and continue to brake after stop and compensate for inaccuracies in the next command\n\n##### acceleration: int\n\nThe acceleration (deg/sec²) (1 - 10000)\n\n##### deceleration: int\n\nThe deceleration (deg/sec²) (1 - 10000)\n\n#### run_to_relative_position\n\nrun_to_relative_position(port: int, position: int, velocity: int, *, stop: int = BRAKE, acceleration: int = 1000, deceleration: int = 1000) -> Awaitable\n\nTurn a motor to a position relative to the current position.  \nWhen awaited returns a status of the movement that corresponds to one of the following constants:\n\n`motor.READY`  \n`motor.RUNNING`  \n`motor.STALLED`  \n`motor.CANCELED`  \n`motor.ERROR`  \n`motor.DISCONNECTED`\n\n##### Parameters\n\n- - -\n\n##### port: int\n\nA port from the `port` submodule in the `hub` module\n\n##### position: int\n\nThe degree of the motor\n\n##### velocity: int\n\nThe velocity in degrees/sec\n\nValue ranges depends on motor type.\n\nSmall motor (essential): -660 to 660  \nMedium motor: -1110 to 1110  \nLarge motor: -1050 to 1050\n\n##### Optional keyword arguments:\n\n##### stop: int\n\nThe behavior of the Motor after it has stopped. Use the constants in the `motor` module.\n\nPossible values are  \n`motor.COAST` to make the motor coast until a stop  \n`motor.BREAK` to brake and continue to brake after stop  \n`motor.HOLD` to tell the motor to hold it's position  \n`motor.CONTINUE` to tell the motor to keep running at whatever velocity it's running at until it gets another command  \n`motor.SMART_COAST` to make the motor brake until stop and then coast and compensate for inaccuracies in the next command  \n`motor.SMART_BRAKE` to make the motor brake and continue to brake after stop and compensate for inaccuracies in the next command\n\n##### acceleration: int\n\nThe acceleration (deg/sec²) (1 - 10000)\n\n##### deceleration: int\n\nThe deceleration (deg/sec²) (1 - 10000)\n\n#### set_duty_cycle\n\nset_duty_cycle(port: int, pwm: int) -> None\n\nStart a Motor with a specific pwm\n\n##### Parameters\n\n- - -\n\n##### port: int\n\nA port from the `port` submodule in the `hub` module\n\n##### pwm: int\n\nThe PWM value (-10000-10000)\n\n#### stop\n\nstop(port: int, *, stop: int = BRAKE) -> None\n\nStops a motor\n\n```\nfrom hub import port\nimport motor, time\n\n# Start motor \nmotor.run(port.A, 1000)\n\n# Wait for 2 seconds \ntime.sleep_ms(2000)\n\n# Stop motor \nmotor.stop(port.A)\n```\n\n##### Parameters\n\n- - -\n\n##### port: int\n\nA port from the `port` submodule in the `hub` module\n\n##### Optional keyword arguments:\n\n##### stop: int\n\nThe behavior of the Motor after it has stopped. Use the constants in the `motor` module.\n\nPossible values are  \n`motor.COAST` to make the motor coast until a stop  \n`motor.BREAK` to brake and continue to brake after stop  \n`motor.HOLD` to tell the motor to hold it's position  \n`motor.CONTINUE` to tell the motor to keep running at whatever velocity it's running at until it gets another command  \n`motor.SMART_COAST` to make the motor brake until stop and then coast and compensate for inaccuracies in the next command  \n`motor.SMART_BRAKE` to make the motor brake and continue to brake after stop and compensate for inaccuracies in the next command\n\n#### velocity\n\nvelocity(port: int) -> int\n\nGet the velocity (deg/sec) of a Motor\n\n##### Parameters\n\n- - -\n\n##### port: int\n\nA port from the `port` submodule in the `hub` module\n\n#### Constants\n\n- - -\n\n#### motor Constants\n\n**READY** = 0\n\n**RUNNING** = 1\n\n**STALLED** = 2\n\n**CANCELLED** = 3\n\n**ERROR** = 4\n\n**DISCONNECTED** = 5\n\n**COAST** = 0\n\n**BRAKE** = 1\n\n**HOLD** = 2\n\n**CONTINUE** = 3\n\n**SMART_COAST** = 4\n\n**SMART_BRAKE** = 5\n\n**CLOCKWISE** = 0\n\n**COUNTERCLOCKWISE** = 1\n\n**SHORTEST_PATH** = 2\n\n**LONGEST_PATH** = 3\n\n"
    },
    {
        "text": "### Motor Pair\n\nThe `motor_pair` module is used to run motors in a synchronized fashion. This mode is optimal for creating drivebases where you'd want a pair of motors to start and stop at the same time.\n\nTo use the `motor_pair` module simply import the module like so:\n\n```\nimport motor_pair\n```\n\nAll functions in the module should be called inside the `motor_pair` module as a prefix like so:\n\n```\nmotor_pair.pair(motor_pair.PAIR_1, port.A, port.B)\n```\n\n#### Functions\n\n#### move\n\nmove(pair: int, steering: int, *, velocity: int = 360, acceleration: int = 1000) -> None\n\nMove a Motor Pair at a constant speed until a new command is given.\n\n```\nfrom hub import port\nimport runloop\nimport motor_pair\n\nasync def main():\n    # Pair motors on port A and B \n    motor_pair.pair(motor_pair.PAIR_1, port.A, port.B)\n\n    await runloop.sleep_ms(2000)\n\n    # Move straight at default velocity \n    motor_pair.move(motor_pair.PAIR_1, 0)\n\n    await runloop.sleep_ms(2000)\n\n    # Move straight at a specific velocity \n    motor_pair.move(motor_pair.PAIR_1, 0, velocity=280)\n\n    await runloop.sleep_ms(2000)\n\n    # Move straight at a specific velocity and acceleration \n    motor_pair.move(motor_pair.PAIR_1, 0, velocity=280, acceleration=100)\n\nrunloop.run(main())\n```\n\n##### Parameters\n\n- - -\n\n##### pair: int\n\nThe pair slot of the Motor Pair.\n\n##### steering: int\n\nThe steering (-100 to 100)\n\n##### Optional keyword arguments:\n\n##### velocity: int\n\nThe velocity in degrees/sec\n\nValue ranges depends on motor type.\n\nSmall motor (essential): -660 to 660  \nMedium motor: -1110 to 1110  \nLarge motor: -1050 to 1050\n\n##### acceleration: int\n\nThe acceleration (deg/sec²) (1 - 10000)\n\n#### move_for_degrees\n\nmove_for_degrees(pair: int, degrees: int, steering: int, *, velocity: int = 360, stop: int = motor.BRAKE, acceleration: int = 1000, deceleration: int = 1000) -> Awaitable\n\nMove a Motor Pair at a constant speed for a specific number of degrees.  \nWhen awaited returns a status of the movement that corresponds to one of the following constants from the motor module:\n\n`motor.READY`  \n`motor.RUNNING`  \n`motor.STALLED`  \n`motor.CANCELED`  \n`motor.ERROR`  \n`motor.DISCONNECTED`\n\n```\nfrom hub import port\nimport runloop\nimport motor_pair\n\nasync def main():\n    # Pair motors on port A and B \n    motor_pair.pair(motor_pair.PAIR_1, port.A, port.B)\n\n    # Move straight at default velocity for 90 degrees \n    await motor_pair.move_for_degrees(motor_pair.PAIR_1, 90, 0)\n\n    # Move straight at a specific velocity \n    await motor_pair.move_for_degrees(motor_pair.PAIR_1, 360, 0, velocity=280)\n\n    # Move straight at a specific velocity with a slow deceleration \n    await motor_pair.move_for_degrees(motor_pair.PAIR_1, 360, 0, velocity=280, deceleration=10)\n\nrunloop.run(main())\n```\n\n##### Parameters\n\n- - -\n\n##### pair: int\n\nThe pair slot of the Motor Pair.\n\n##### degrees: int\n\nThe number of degrees\n\n##### steering: int\n\nThe steering (-100 to 100)\n\n##### Optional keyword arguments:\n\n##### velocity: int\n\nThe velocity in degrees/sec\n\nValue ranges depends on motor type.\n\nSmall motor (essential): -660 to 660  \nMedium motor: -1110 to 1110  \nLarge motor: -1050 to 1050\n\n##### stop: int\n\nThe behavior of the Motor after it has stopped. Use the constants in the `motor` module.\n\nPossible values are  \n`motor.COAST` to make the motor coast until a stop  \n`motor.BREAK` to brake and continue to brake after stop  \n`motor.HOLD` to tell the motor to hold it's position  \n`motor.CONTINUE` to tell the motor to keep running at whatever velocity it's running at until it gets another command  \n`motor.SMART_COAST` to make the motor brake until stop and then coast and compensate for inaccuracies in the next command  \n`motor.SMART_BRAKE` to make the motor brake and continue to brake after stop and compensate for inaccuracies in the next command\n\n##### acceleration: int\n\nThe acceleration (deg/sec²) (1 - 10000)\n\n##### deceleration: int\n\nThe deceleration (deg/sec²) (1 - 10000)\n\n#### move_for_time\n\nmove_for_time(pair: int, duration: int, steering: int, *, velocity: int = 360, stop: int = motor.BRAKE, acceleration: int = 1000, deceleration: int = 1000) -> Awaitable\n\nMove a Motor Pair at a constant speed for a specific duration.  \nWhen awaited returns a status of the movement that corresponds to one of the following constants from the motor module:\n\n`motor.READY`  \n`motor.RUNNING`  \n`motor.STALLED`  \n`motor.CANCELED`  \n`motor.ERROR`  \n`motor.DISCONNECTED`\n\n```\nfrom hub import port\nimport runloop\nimport motor_pair\n\nasync def main():\n    # Pair motors on port A and B \n    motor_pair.pair(motor_pair.PAIR_1, port.A, port.B)\n\n    # Move straight at default velocity for 1 second \n    await motor_pair.move_for_time(motor_pair.PAIR_1, 1000, 0)\n\n    # Move straight at a specific velocity for 1 second \n    await motor_pair.move_for_time(motor_pair.PAIR_1, 1000, 0, velocity=280)\n\n    # Move straight at a specific velocity for 10 seconds with a slow deceleration \n    await motor_pair.move_for_time(motor_pair.PAIR_1, 10000, 0, velocity=280, deceleration=10)\n\nrunloop.run(main())\n```\n\n##### Parameters\n\n- - -\n\n##### pair: int\n\nThe pair slot of the Motor Pair.\n\n##### duration: int\n\nThe duration in milliseconds\n\n##### steering: int\n\nThe steering (-100 to 100)\n\n##### Optional keyword arguments:\n\n##### velocity: int\n\nThe velocity in degrees/sec\n\nValue ranges depends on motor type.\n\nSmall motor (essential): -660 to 660  \nMedium motor: -1110 to 1110  \nLarge motor: -1050 to 1050\n\n##### stop: int\n\nThe behavior of the Motor after it has stopped. Use the constants in the `motor` module.\n\nPossible values are  \n`motor.COAST` to make the motor coast until a stop  \n`motor.BREAK` to brake and continue to brake after stop  \n`motor.HOLD` to tell the motor to hold it's position  \n`motor.CONTINUE` to tell the motor to keep running at whatever velocity it's running at until it gets another command  \n`motor.SMART_COAST` to make the motor brake until stop and then coast and compensate for inaccuracies in the next command  \n`motor.SMART_BRAKE` to make the motor brake and continue to brake after stop and compensate for inaccuracies in the next command\n\n##### acceleration: int\n\nThe acceleration (deg/sec²) (1 - 10000)\n\n##### deceleration: int\n\nThe deceleration (deg/sec²) (1 - 10000)\n\n#### move_tank\n\nmove_tank(pair: int, left_velocity: int, right_velocity: int, *, acceleration: int = 1000) -> None\n\nPerform a tank move on a Motor Pair at a constant speed until a new command is given.\n\n```\nfrom hub import port\nimport runloop\nimport motor_pair\n\nasync def main():\n    # Pair motors on port A and B \n    motor_pair.pair(motor_pair.PAIR_1, port.A, port.B)\n\n    # Move straight at default velocity \n    motor_pair.move_tank(motor_pair.PAIR_1, 1000, 1000)\n\n    await runloop.sleep_ms(2000)\n\n    # Turn right \n    motor_pair.move_tank(motor_pair.PAIR_1, 0, 1000)\n\n    await runloop.sleep_ms(2000)\n\n    # Perform tank turn \n    motor_pair.move_tank(motor_pair.PAIR_1, 1000, -1000)\n\nrunloop.run(main())\n```\n\n##### Parameters\n\n- - -\n\n##### pair: int\n\nThe pair slot of the Motor Pair.\n\n##### left_velocity: int\n\nThe velocity (deg/sec) of the left motor.\n\n##### right_velocity: int\n\nThe velocity (deg/sec) of the right motor.\n\n##### Optional keyword arguments:\n\n##### acceleration: int\n\nThe acceleration (deg/sec²) (1 - 10000)\n\n#### move_tank_for_degrees\n\nmove_tank_for_degrees(pair: int, degrees: int, left_velocity: int, right_velocity: int, *, stop: int = motor.BRAKE, acceleration: int = 1000, deceleration: int = 1000) -> Awaitable\n\nPerform a tank move on a Motor Pair at a constant speed until a new command is given.  \nWhen awaited returns a status of the movement that corresponds to one of the following constants from the motor module:\n\n`motor.READY`  \n`motor.RUNNING`  \n`motor.STALLED`  \n`motor.CANCELED`  \n`motor.ERROR`  \n`motor.DISCONNECTED`\n\n```\nfrom hub import port\nimport runloop\nimport motor_pair\n\nasync def main():\n    # Pair motors on port A and B \n    motor_pair.pair(motor_pair.PAIR_1, port.A, port.B)\n\n    # Move straight at default velocity for 360 degrees \n    await motor_pair.move_tank_for_degrees(motor_pair.PAIR_1, 360, 1000, 1000)\n\n    # Turn right for 180 degrees \n    await motor_pair.move_tank_for_degrees(motor_pair.PAIR_1, 180, 0, 1000)\n\n    # Perform tank turn for 720 degrees \n    await motor_pair.move_tank_for_degrees(motor_pair.PAIR_1, 720, 1000, -1000)\n\nrunloop.run(main())\n```\n\n##### Parameters\n\n- - -\n\n##### pair: int\n\nThe pair slot of the Motor Pair.\n\n##### degrees: int\n\nThe number of degrees\n\n##### left_velocity: int\n\nThe velocity (deg/sec) of the left motor.\n\n##### right_velocity: int\n\nThe velocity (deg/sec) of the right motor.\n\n##### Optional keyword arguments:\n\n##### stop: int\n\nThe behavior of the Motor after it has stopped. Use the constants in the `motor` module.\n\nPossible values are  \n`motor.COAST` to make the motor coast until a stop  \n`motor.BREAK` to brake and continue to brake after stop  \n`motor.HOLD` to tell the motor to hold it's position  \n`motor.CONTINUE` to tell the motor to keep running at whatever velocity it's running at until it gets another command  \n`motor.SMART_COAST` to make the motor brake until stop and then coast and compensate for inaccuracies in the next command  \n`motor.SMART_BRAKE` to make the motor brake and continue to brake after stop and compensate for inaccuracies in the next command\n\n##### acceleration: int\n\nThe acceleration (deg/sec²) (1 - 10000)\n\n##### deceleration: int\n\nThe deceleration (deg/sec²) (1 - 10000)\n\n#### move_tank_for_time\n\nmove_tank_for_time(pair: int, left_velocity: int, right_velocity: int, duration: int, *, stop: int = motor.BRAKE, acceleration: int = 1000, deceleration: int = 1000) -> Awaitable\n\nPerform a tank move on a Motor Pair at a constant speed for a specific amount of time.  \nWhen awaited returns a status of the movement that corresponds to one of the following constants from the motor module:\n\n`motor.READY`  \n`motor.RUNNING`  \n`motor.STALLED`  \n`motor.CANCELED`  \n`motor.ERROR`  \n`motor.DISCONNECTED`\n\n```\nfrom hub import port\nimport runloop\nimport motor_pair\n\nasync def main():\n    # Pair motors on port A and B \n    motor_pair.pair(motor_pair.PAIR_1, port.A, port.B)\n\n    # Move straight at default velocity for 1 second \n    await motor_pair.move_tank_for_time(motor_pair.PAIR_1, 1000, 1000, 1000)\n\n    # Turn right for 3 seconds \n    await motor_pair.move_tank_for_time(motor_pair.PAIR_1, 0, 1000, 3000)\n\n    # Perform tank turn for 2 seconds \n    await motor_pair.move_tank_for_time(motor_pair.PAIR_1, 1000, -1000, 2000)\n\nrunloop.run(main())\n```\n\n##### Parameters\n\n- - -\n\n##### pair: int\n\nThe pair slot of the Motor Pair.\n\n##### duration: int\n\nThe duration in milliseconds\n\n##### left_velocity: int\n\nThe velocity (deg/sec) of the left motor.\n\n##### right_velocity: int\n\nThe velocity (deg/sec) of the right motor.\n\n##### Optional keyword arguments:\n\n##### stop: int\n\nThe behavior of the Motor after it has stopped. Use the constants in the `motor` module.\n\nPossible values are  \n`motor.COAST` to make the motor coast until a stop  \n`motor.BREAK` to brake and continue to brake after stop  \n`motor.HOLD` to tell the motor to hold it's position  \n`motor.CONTINUE` to tell the motor to keep running at whatever velocity it's running at until it gets another command  \n`motor.SMART_COAST` to make the motor brake until stop and then coast and compensate for inaccuracies in the next command  \n`motor.SMART_BRAKE` to make the motor brake and continue to brake after stop and compensate for inaccuracies in the next command\n\n##### acceleration: int\n\nThe acceleration (deg/sec²) (1 - 10000)\n\n##### deceleration: int\n\nThe deceleration (deg/sec²) (1 - 10000)\n\n#### pair\n\npair(pair: int, left_motor: int, right_motor: int) -> None\n\npair two motors (`left_motor` & `right_motor`) and store the paired motors in `pair`.  \nUse `pair` in all subsequent `motor_pair` related function calls.\n\n```\nimport motor_pair\nfrom hub import port\n\nmotor_pair.pair(motor_pair.PAIR_1, port.A, port.B)\n```\n\n##### Parameters\n\n- - -\n\n##### pair: int\n\nThe pair slot of the Motor Pair.\n\n##### left_motor: int\n\nThe port of the left motor. Use the `port` submodule in the `hub` module.\n\n##### right_motor: int\n\nThe port of the right motor. Use the `port` submodule in the `hub` module.\n\n#### stop\n\nstop(pair: int, *, stop: int = motor.BRAKE) -> None\n\nStops a Motor Pair.\n\n```\nimport motor_pair\n\nmotor_pair.stop(motor_pair.PAIR_1)\n```\n\n##### Parameters\n\n- - -\n\n##### pair: int\n\nThe pair slot of the Motor Pair.\n\n##### Optional keyword arguments:\n\n##### stop: int\n\nThe behavior of the Motor after it has stopped. Use the constants in the `motor` module.\n\nPossible values are  \n`motor.COAST` to make the motor coast until a stop  \n`motor.BREAK` to brake and continue to brake after stop  \n`motor.HOLD` to tell the motor to hold it's position  \n`motor.CONTINUE` to tell the motor to keep running at whatever velocity it's running at until it gets another command  \n`motor.SMART_COAST` to make the motor brake until stop and then coast and compensate for inaccuracies in the next command  \n`motor.SMART_BRAKE` to make the motor brake and continue to brake after stop and compensate for inaccuracies in the next command\n\n#### unpair\n\nunpair(pair: int) -> None\n\nUnpair a Motor Pair.\n\n```\nimport motor_pair\n\nmotor_pair.unpair(motor_pair.PAIR_1)\n```\n\n##### Parameters\n\n- - -\n\n##### pair: int\n\nThe pair slot of the Motor Pair.\n\n#### Constants\n\n- - -\n\n#### motor_pair Constants\n\n**PAIR_1** = 0  \nFirst Motor Pair  \n**PAIR_2** = 1  \nSecond Motor Pair  \n**PAIR_3** = 2  \nThird Motor Pair\n\n"
    },
    {
        "text": "### Orientation\n\nThe `orientation` module contains all the orientation constants to use with the `light_matrix` module.\n\nTo use the orientation module add the following import statement to your project:\n\n```\nimport orientation\n```\n\n#### Constants\n\n- - -\n\n#### orientation Constants\n\n**UP** = 0\n\n**RIGHT** = 1\n\n**DOWN** = 2\n\n**LEFT** = 3\n\n"
    },
    {
        "text": "### Runloop\n\nThe `runloop` module contains all functions and constants to use the Runloop.\n\nTo use the Runloop module add the following import statement to your project:\n\n```\nimport runloop\n```\n\nAll functions in the module should be called inside the `runloop` module as a prefix like so:\n\n```\nrunloop.run(some_async_function())\n```\n\n#### Functions\n\n#### run\n\nrun(*functions: Awaitable) -> None\n\nStart any number of parallel `async` functions. This is the function you should use to create programs with a similar structure to Word Blocks.\n\n##### Parameters\n\n- - -\n\n##### *functions: awaitable\n\nThe functions to run\n\n#### sleep_ms\n\nsleep_ms(duration: int) -> Awaitable\n\nPause the execution of the application for any amount of milliseconds.\n\n```\nfrom hub import light_matrix\nimport runloop\n\nasync def main():\n    light_matrix.write(\"Hi!\")\n    # Wait for ten seconds \n    await runloop.sleep_ms(10000)\n    light_matrix.write(\"Are you still here?\")\n\nrunloop.run(main())\n```\n\n##### Parameters\n\n- - -\n\n##### duration: int\n\nThe duration in milliseconds\n\n#### until\n\nuntil(function: Callable[[], bool], timeout: int = 0) -> Awaitable\n\nReturns an awaitable that will return when the condition in the function or lambda passed is `True` or when it times out\n\n```\nimport color_sensor\nimport color\nfrom hub import port\nimport runloop\n\ndef is_color_red():\n    return color_sensor.color(port.A) is color.RED\n\nasync def main():\n    # Wait until Color Sensor sees red \n    await runloop.until(is_color_red)\n    print(\"Red!\")\n\nrunloop.run(main())\n```\n\n##### Parameters\n\n- - -\n\n##### function: Callable[[], bool]\n\nA callable with no parameters that returns either `True` or `False`.  \nCallable is anything that can be called, so a `def` or a `lambda`\n\n##### timeout: int\n\nA timeout for the function in milliseconds.  \nIf the callable does not return `True` within the timeout, the `until` still resolves after the timeout.  \n0 means no timeout, in that case it will not resolve until the callable returns `True`"
    }
]