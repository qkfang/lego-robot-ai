require('dotenv').config();
const { MongoClient } = require('mongodb');

async function main() {
    const client = new MongoClient(process.env.MONGODB_URI);
    try {
        await client.connect();
        console.log('Connected to MongoDB');

        const db = client.db('legorobot');

        // legoapi
        {
            const legoapis = db.collection('legoapi');
            await legoapis.deleteMany({});
            const legoapisToInsert = [
                {
                    "text": "### App\n\nThe `app` module is used communicate between hub and app\n\n#### Sub Modules\n\n#### Bargraph\n\nThe `bargraph` module is used make bar graphs in the SPIKE App\n\nTo use the `bargraph` module simply import the module like so:\n\n```\nfrom app import bargraph\n```\n\n`bargraph` details\n\n##### Functions\n\n##### change\n\nchange(color: int, value: float) -> None\n\n###### Parameters\n\n- - -\n\n###### color: int\n\nA color from the `color` module\n\n###### value: float\n\nThe value\n\n##### clear_all\n\nclear_all() -> None\n\n###### Parameters\n\n- - -\n\n##### get_value\n\nget_value(color: int) -> Awaitable\n\n###### Parameters\n\n- - -\n\n###### color: int\n\nA color from the `color` module\n\n##### hide\n\nhide() -> None\n\n###### Parameters\n\n- - -\n\n##### set_value\n\nset_value(color: int, value: float) -> None\n\n###### Parameters\n\n- - -\n\n###### color: int\n\nA color from the `color` module\n\n###### value: float\n\nThe value\n\n##### show\n\nshow(fullscreen: bool) -> None\n\n###### Parameters\n\n- - -\n\n###### fullscreen: bool\n\nShow in full screen\n\n#### Display\n\nThe `display` module is used show images in the SPIKE App\n\nTo use the `display` module simply import the module like so:\n\n```\nfrom app import display\n```\n\n`display` details\n\n##### Functions\n\n##### hide\n\nhide() -> None\n\n###### Parameters\n\n- - -\n\n##### image\n\nimage(image: int) -> None\n\n###### Parameters\n\n- - -\n\n###### image: int\n\nThe id of the image to show. The range of available images is 1 to 21. There are consts on the `display` module for these\n\n##### show\n\nshow(fullscreen: bool) -> None\n\n###### Parameters\n\n- - -\n\n###### fullscreen: bool\n\nShow in full screen\n\n##### text\n\ntext(text: str) -> None\n\n###### Parameters\n\n- - -\n\n###### text: str\n\nThe text to display\n\n##### Constants\n\n- - -\n\n##### app.display Constants\n\n**IMAGE_ROBOT_1** = 1\n\n**IMAGE_ROBOT_2** = 2\n\n**IMAGE_ROBOT_3** = 3\n\n**IMAGE_ROBOT_4** = 4\n\n**IMAGE_ROBOT_5** = 5\n\n**IMAGE_HUB_1** = 6\n\n**IMAGE_HUB_2** = 7\n\n**IMAGE_HUB_3** = 8\n\n**IMAGE_HUB_4** = 9\n\n**IMAGE_AMUSEMENT_PARK** = 10\n\n**IMAGE_BEACH** = 11\n\n**IMAGE_HAUNTED_HOUSE** = 12\n\n**IMAGE_CARNIVAL** = 13\n\n**IMAGE_BOOKSHELF** = 14\n\n**IMAGE_PLAYGROUND** = 15\n\n**IMAGE_MOON** = 16\n\n**IMAGE_CAVE** = 17\n\n**IMAGE_OCEAN** = 18\n\n**IMAGE_POLAR_BEAR** = 19\n\n**IMAGE_PARK** = 20\n\n**IMAGE_RANDOM** = 21\n\n#### Linegraph\n\nThe `linegraph` module is used make line graphs in the SPIKE App\n\nTo use the `linegraph` module simply import the module like so:\n\n```\nfrom app import linegraph\n```\n\n`linegraph` details\n\n##### Functions\n\n##### clear\n\nclear(color: int) -> None\n\n###### Parameters\n\n- - -\n\n###### color: int\n\nA color from the `color` module\n\n##### clear_all\n\nclear_all() -> None\n\n###### Parameters\n\n- - -\n\n##### get_average\n\nget_average(color: int) -> Awaitable\n\n###### Parameters\n\n- - -\n\n###### color: int\n\nA color from the `color` module\n\n##### get_last\n\nget_last(color: int) -> Awaitable\n\n###### Parameters\n\n- - -\n\n###### color: int\n\nA color from the `color` module\n\n##### get_max\n\nget_max(color: int) -> Awaitable\n\n###### Parameters\n\n- - -\n\n###### color: int\n\nA color from the `color` module\n\n##### get_min\n\nget_min(color: int) -> Awaitable\n\n###### Parameters\n\n- - -\n\n###### color: int\n\nA color from the `color` module\n\n##### hide\n\nhide() -> None\n\n###### Parameters\n\n- - -\n\n##### plot\n\nplot(color: int, x: float, y: float) -> None\n\n###### Parameters\n\n- - -\n\n###### color: int\n\nA color from the `color` module\n\n###### x: float\n\nThe X value\n\n###### y: float\n\nThe Y value\n\n##### show\n\nshow(fullscreen: bool) -> None\n\n###### Parameters\n\n- - -\n\n###### fullscreen: bool\n\nShow in full screen\n\n#### Music\n\nThe `music` module is used make music in the SPIKE App\n\nTo use the `music` module simply import the module like so:\n\n```\nfrom app import music\n```\n\n`music` details\n\n##### Functions\n\n##### play_drum\n\nplay_drum(drum: int) -> None\n\n###### Parameters\n\n- - -\n\n###### drum: int\n\nThe drum name. See all available values in the app.sound module.\n\n##### play_instrument\n\nplay_instrument(instrument: int, note: int, duration: int) -> None\n\n###### Parameters\n\n- - -\n\n###### instrument: int\n\nThe instrument name. See all available values in the app.music module.\n\n###### note: int\n\nThe midi note to play (0-130)\n\n###### duration: int\n\nThe duration in milliseconds\n\n##### Constants\n\n- - -\n\n##### app.music Constants\n\n**DRUM_BASS** = 2\n\n**DRUM_BONGO** = 13\n\n**DRUM_CABASA** = 15\n\n**DRUM_CLAVES** = 9\n\n**DRUM_CLOSED_HI_HAT** = 6\n\n**DRUM_CONGA** = 14\n\n**DRUM_COWBELL** = 11\n\n**DRUM_CRASH_CYMBAL** = 4\n\n**DRUM_CUICA** = 18\n\n**DRUM_GUIRO** = 16\n\n**DRUM_HAND_CLAP** = 8\n\n**DRUM_OPEN_HI_HAT** = 5\n\n**DRUM_SIDE_STICK** = 3\n\n**DRUM_SNARE** = 1\n\n**DRUM_TAMBOURINE** = 7\n\n**DRUM_TRIANGLE** = 12\n\n**DRUM_VIBRASLAP** = 17\n\n**DRUM_WOOD_BLOCK** = 10\n\n**INSTRUMENT_BASS** = 6\n\n**INSTRUMENT_BASSOON** = 14\n\n**INSTRUMENT_CELLO** = 8\n\n**INSTRUMENT_CHOIR** = 15\n\n**INSTRUMENT_CLARINET** = 10\n\n**INSTRUMENT_ELECTRIC_GUITAR** = 5\n\n**INSTRUMENT_ELECTRIC_PIANO** = 2\n\n**INSTRUMENT_FLUTE** = 12\n\n**INSTRUMENT_GUITAR** = 4\n\n**INSTRUMENT_MARIMBA** = 19\n\n**INSTRUMENT_MUSIC_BOX** = 17\n\n**INSTRUMENT_ORGAN** = 3\n\n**INSTRUMENT_PIANO** = 1\n\n**INSTRUMENT_PIZZICATO** = 7\n\n**INSTRUMENT_SAXOPHONE** = 11\n\n**INSTRUMENT_STEEL_DRUM** = 18\n\n**INSTRUMENT_SYNTH_LEAD** = 20\n\n**INSTRUMENT_SYNTH_PAD** = 21\n\n**INSTRUMENT_TROMBONE** = 9\n\n**INSTRUMENT_VIBRAPHONE** = 16\n\n**INSTRUMENT_WOODEN_FLUTE** = 13\n\n#### Sound\n\nThe `sound` module is used play sounds in the SPIKE App\n\nTo use the `sound` module simply import the module like so:\n\n```\nfrom app import sound\n```\n\n`sound` details\n\n##### Functions\n\n##### play\n\nplay(sound_name: str, volume: int = 100, pitch: int = 0, pan: int = 0) -> Awaitable\n\nPlay a sound in the SPIKE App\n\n###### Parameters\n\n- - -\n\n###### sound_name: str\n\nThe sound name as seen in the Word Blocks sound extension\n\n###### volume: int\n\nThe volume (0-100)\n\n###### pitch: int\n\nThe pitch of the sound\n\n###### pan: int\n\nThe pan effect determines which speaker is emitting the sound, with \"-100\" being only the left speaker, \"0\" being normal, and \"100\" being only the right speaker.\n\n##### set_attributes\n\nset_attributes(volume: int, pitch: int, pan: int) -> None\n\n###### Parameters\n\n- - -\n\n###### volume: int\n\nThe volume (0-100)\n\n###### pitch: int\n\nThe pitch of the sound\n\n###### pan: int\n\nThe pan effect determines which speaker is emitting the sound, with \"-100\" being only the left speaker, \"0\" being normal, and \"100\" being only the right speaker.\n\n##### stop\n\nstop() -> None\n\n###### Parameters\n\n- - -\n\n"
                },
                {
                    "text": "### Color\n\nThe `color` module contains all the color constants to use with the `color_matrix`, `color_sensor` and `light` modules.\n\nTo use the Color module add the following import statement to your project:\n\n```\nimport color\n```\n\n#### Constants\n\n- - -\n\n#### color Constants\n\n**BLACK** = 0\n\n**MAGENTA** = 1\n\n**PURPLE** = 2\n\n**BLUE** = 3\n\n**AZURE** = 4\n\n**TURQUOISE** = 5\n\n**GREEN** = 6\n\n**YELLOW** = 7\n\n**ORANGE** = 8\n\n**RED** = 9\n\n**WHITE** = 10\n\n**UNKNOWN** = -1\n\n"
                },
                {
                    "text": "### Color Matrix\n\nTo use the Color Matrix module add the following import statement to your project:\n\n```\nimport color_matrix\n```\n\nAll functions in the module should be called inside the `color_matrix` module as a prefix like so:\n\n```\ncolor_matrix.set_pixel(port.A, 1, 1, (color.BLUE, 10))\n```\n\n#### Functions\n\n#### clear\n\nclear(port: int) -> None\n\nTurn off all pixels on a Color Matrix\n\n```\nfrom hub import port\nimport color_matrix\n\ncolor_matrix.clear(port.A)\n```\n\n##### Parameters\n\n- - -\n\n##### port: int\n\nA port from the `port` submodule in the `hub` module\n\n#### get_pixel\n\nget_pixel(port: int, x: int, y: int) -> tuple[int, int]\n\nRetrieve a specific pixel represented as a tuple containing the color and intensity\n\n```\nfrom hub import port\nimport color_matrix\n\n# Print the color and intensity of the 0,0 pixel on the Color Matrix connected to port A \nprint(color_matrix.get_pixel(port.A, 0, 0))\n```\n\n##### Parameters\n\n- - -\n\n##### port: int\n\nA port from the `port` submodule in the `hub` module\n\n##### x: int\n\nThe X value (0 - 2)\n\n##### y: int\n\nThe Y value, range (0 - 2)\n\n#### set_pixel\n\nset_pixel(port: int, x: int, y: int, pixel: tuple[color: int, intensity: int]) -> None\n\nChange a single pixel on a Color Matrix\n\n```\nfrom hub import port\nimport color\nimport color_matrix\n\n# Change the color of the 0,0 pixel on the Color Matrix connected to port A \ncolor_matrix.set_pixel(port.A, 0, 0, (color.RED, 10))\n\n# Print the color of the 0,0 pixel on the Color Matrix connected to port A \nprint(color_matrix.get_pixel(port.A, 0, 0)[0])\n```\n\n##### Parameters\n\n- - -\n\n##### port: int\n\nA port from the `port` submodule in the `hub` module\n\n##### x: int\n\nThe X value (0 - 2)\n\n##### y: int\n\nThe Y value, range (0 - 2)\n\n##### pixel: tuple[color: int, intensity: int]\n\nTuple containing color and intensity, meaning how bright to light up the pixel\n\n#### show\n\nshow(port: int, pixels: list[tuple[int, int]]) -> None\n\nChange all pixels at once on a Color Matrix\n\n```\nfrom hub import port\nimport color\nimport color_matrix\n\n# Update all pixels on Color Matrix using the show function \n\n# Create a list with 18 items (color and intensity pairs) \npixels = [(color.BLUE, 10)] * 9 \n\n# Update all pixels to show same color and intensity \ncolor_matrix.show(port.A, pixels)\n```\n\n##### Parameters\n\n- - -\n\n##### port: int\n\nA port from the `port` submodule in the `hub` module\n\n##### pixels: list[tuple[int, int]]\n\nA list containing color and intensity value tuples for all 9 pixels.\n\n"
                },
                {
                    "text": "### Color Sensor\n\nThe `color_sensor` module enables you to write code that reacts to specific colors or the intensity of the reflected light.\n\nTo use the Color Sensor module add the following import statement to your project:\n\n```\nimport color_sensor\n```\n\nAll functions in the module should be called inside the `color_sensor` module as a prefix like so:\n\n```\ncolor_sensor.reflection(port.A)\n```\n\nThe Color Sensor can recognize the following colors:\n\nRed  \nGreen  \nBlue  \nMagenta  \nYellow  \nOrange  \nAzure  \nBlack  \nWhite\n\n#### Functions\n\n#### color\n\ncolor(port: int) -> int\n\nReturns the color value of the detected color. Use the `color` module to map the color value to a specific color.\n\n```\nimport color_sensor\nfrom hub import port\nimport color\n\nif color_sensor.color(port.A) is color.RED:\n    print(\"Red detected\")\n```\n\n##### Parameters\n\n- - -\n\n##### port: int\n\nA port from the `port` submodule in the `hub` module\n\n#### reflection\n\nreflection(port: int) -> int\n\nRetrieves the intensity of the reflected light (0-100%).\n\n##### Parameters\n\n- - -\n\n##### port: int\n\nA port from the `port` submodule in the `hub` module\n\n#### rgbi\n\nrgbi(port: int) -> tuple[int, int, int, int]\n\nRetrieves the overall color intensity and intensity of red, green and blue.\n\nReturns tuple[red: int, green: int, blue: int, intensity: int]\n\n##### Parameters\n\n- - -\n\n##### port: int\n\nA port from the `port` submodule in the `hub` module\n\n"
                },
                {
                    "text": "### Device\n\nThe `device` module enables you to write code to get information about devices plugged into the hub.\n\nTo use the Device module add the following import statement to your project:\n\n```\nimport device\n```\n\nAll functions in the module should be called inside the `device` module as a prefix like so:\n\n```\ndevice.device_id(port.A)\n```\n\n#### Functions\n\n#### data\n\ndata(port: int) -> tuple[int]\n\nRetrieve the raw LPF-2 data from a device.\n\n##### Parameters\n\n- - -\n\n##### port: int\n\nA port from the `port` submodule in the `hub` module\n\n#### id\n\nid(port: int) -> int\n\nRetrieve the device id of a device. Each device has an id based on its type.\n\n##### Parameters\n\n- - -\n\n##### port: int\n\nA port from the `port` submodule in the `hub` module\n\n#### get_duty_cycle\n\nget_duty_cycle(port: int) -> int\n\nRetrieve the duty cycle for a device. Returned values is in range 0 to 10000\n\n##### Parameters\n\n- - -\n\n##### port: int\n\nA port from the `port` submodule in the `hub` module\n\n#### ready\n\nready(port: int) -> bool\n\nWhen a device is attached to the hub it might take a short amount of time before it's ready to accept requests.  \nUse `ready` to test for the readiness of the attached devices.\n\n##### Parameters\n\n- - -\n\n##### port: int\n\nA port from the `port` submodule in the `hub` module\n\n#### set_duty_cycle\n\nset_duty_cycle(port: int, duty_cycle: int) -> None\n\nSet the duty cycle on a device. Range 0 to 10000\n\n##### Parameters\n\n- - -\n\n##### port: int\n\nA port from the `port` submodule in the `hub` module\n\n##### duty_cycle: int\n\nThe PWM value (0-10000)\n\n"
                },
                {
                    "text": "### Distance Sensor\n\nThe `distance_sensor` module enables you to write code that reacts to specific distances or light up the Distance Sensor in different ways.\n\nTo use the Distance Sensor module add the following import statement to your project:\n\n```\nimport distance_sensor\n```\n\nAll functions in the module should be called inside the `distance_sensor` module as a prefix like so:\n\n```\ndistance_sensor.distance(port.A)\n```\n\n#### Functions\n\n#### clear\n\nclear(port: int) -> None\n\nTurns off all the lights in the Distance Sensor connected to `port`.\n\n##### Parameters\n\n- - -\n\n##### port: int\n\nA port from the `port` submodule in the `hub` module\n\n#### distance\n\ndistance(port: int) -> int\n\nRetrieve the distance in millimeters captured by the Distance Sensor connected to `port`. If the Distance Sensor cannot read a valid distance it will return -1.\n\n##### Parameters\n\n- - -\n\n##### port: int\n\nA port from the `port` submodule in the `hub` module\n\n#### get_pixel\n\nget_pixel(port: int, x: int, y: int) -> int\n\nRetrieve the intensity of a specific light on the Distance Sensor connected to `port`.\n\n##### Parameters\n\n- - -\n\n##### port: int\n\nA port from the `port` submodule in the `hub` module\n\n##### x: int\n\nThe X value (0 - 3)\n\n##### y: int\n\nThe Y value, range (0 - 3)\n\n#### set_pixel\n\nset_pixel(port: int, x: int, y: int, intensity: int) -> None\n\nChanges the intensity of a specific light on the Distance Sensor connected to `port`.\n\n##### Parameters\n\n- - -\n\n##### port: int\n\nA port from the `port` submodule in the `hub` module\n\n##### x: int\n\nThe X value (0 - 3)\n\n##### y: int\n\nThe Y value, range (0 - 3)\n\n##### intensity: int\n\nHow bright to light up the pixel\n\n#### show\n\nshow(port: int, pixels: list[int]) -> None\n\nChange all the lights at the same time.\n\n```\nfrom hub import port\nimport distance_sensor\n\n# Update all pixels on Distance Sensor using the show function \n\n# Create a list with 4 identical intensity values \npixels = [100] * 4 \n\n# Update all pixels to show same intensity \ndistance_sensor.show(port.A, pixels)\n```\n\n##### Parameters\n\n- - -\n\n##### port: int\n\nA port from the `port` submodule in the `hub` module\n\n##### pixels: bytes\n\nA list containing intensity values for all 4 pixels.\n\n"
                },
                {
                    "text": "### Force Sensor\n\nThe `force_sensor` module contains all functions and constants to use the Force Sensor.\n\nTo use the Force Sensor module add the following import statement to your project:\n\n```\nimport force_sensor\n```\n\nAll functions in the module should be called inside the `force_sensor` module as a prefix like so:\n\n```\nforce_sensor.force(port.A)\n```\n\n#### Functions\n\n#### force\n\nforce(port: int) -> int\n\nRetrieves the measured force as decinewton. Values range from 0 to 100\n\n```\nfrom hub import port\nimport force_sensor\n\n\nprint(force_sensor.force(port.A))\n```\n\n##### Parameters\n\n- - -\n\n##### port: int\n\nA port from the `port` submodule in the `hub` module\n\n#### pressed\n\npressed(port: int) -> bool\n\nTests whether the button on the sensor is pressed. Returns true if the force sensor connected to port is pressed.\n\n```\nfrom hub import port\nimport force_sensor\n\n\nprint(force_sensor.pressed(port.A))\n```\n\n##### Parameters\n\n- - -\n\n##### port: int\n\nA port from the `port` submodule in the `hub` module\n\n#### raw\n\nraw(port: int) -> int\n\nReturns the raw, uncalibrated force value of the force sensor connected on port `port`\n\n```\nfrom hub import port\nimport force_sensor\n\n\nprint(force_sensor.raw(port.A))\n```\n\n##### Parameters\n\n- - -\n\n##### port: int\n\nA port from the `port` submodule in the `hub` module\n\n"
                },
                {
                    "text": "### Hub\n\n#### Sub Modules\n\n#### Button\n\nTo use the Button module add the following import statement to your project:\n\n```\nfrom hub import button\n```\n\nAll functions in the module should be called inside the `button` module as a prefix like so:\n\n```\nbutton.pressed(button.LEFT)\n```\n\n##### Functions\n\n##### pressed\n\nint pressed(button: int) -> int\n\nThis module allows you to react to buttons being pressed on the hub. You must first import the `button` module to use the buttons.\n\n```\nfrom hub import button\n\nleft_button_press_duration = 0\n\n# Wait for the left button to be pressed \nwhile not button.pressed(button.LEFT):\n    pass\n\n# As long as the left button is being pressed, update the `left_button_press_duration` variable \nwhile button.pressed(button.LEFT):\n    left_button_press_duration = button.pressed(button.LEFT)\n\nprint(\"Left button was pressed for \" + str(left_button_press_duration) + \" milliseconds\")\n```\n\n###### Parameters\n\n- - -\n\n###### button: int\n\nA button from the `button` submodule in the `hub` module\n\n##### Constants\n\n- - -\n\n##### hub.button Constants\n\n**LEFT** = 1  \nLeft button next to the power button on the SPIKE Prime hub  \n**RIGHT** = 2  \nRight button next to the power button on the SPIKE Prime hub\n\n#### Light\n\nThe `light` module includes functions to change the color of the light on the SPIKE Prime hub.\n\nTo use the Light module add the following import statement to your project:\n\n```\nfrom hub import light\n```\n\nAll functions in the module should be called inside the `light` module as a prefix like so:\n\n```\nlight.color(color.RED)\n```\n\n##### Functions\n\n##### color\n\ncolor(light: int, color: int) -> None\n\nChange the color of a light on the hub.\n\n```\nfrom hub import light\nimport color\n\n# Change the light to red \nlight.color(light.POWER, color.RED)\n```\n\n###### Parameters\n\n- - -\n\n###### light: int\n\nThe light on the hub\n\n###### color: int\n\nA color from the `color` module\n\n##### Constants\n\n- - -\n\n##### hub.light Constants\n\n**POWER** = 0  \nThe power button. On SPIKE Prime it's the button between the left and right buttons.  \n**CONNECT** = 1  \nThe light around the Bluetooth connect button on SPIKE Prime.\n\n#### Light Matrix\n\nTo use the Light Matrix module add the following import statement to your project:\n\n```\nfrom hub import light_matrix\n```\n\nAll functions in the module should be called inside the `light_matrix` module as a prefix like so:\n\n```\nlight_matrix.write(\"Hello World\")\n```\n\n##### Functions\n\n##### clear\n\nclear() -> None\n\nSwitches off all of the pixels on the Light Matrix.\n\n```\nfrom hub import light_matrix\nimport time\n# Update pixels to show an image on Light Matrix, and then turn them off using the clear function \n\n# Show a small heart \nlight_matrix.show_image(2)\n\n# Wait for two seconds \ntime.sleep_ms(2000)\n\n# Switch off the heart \nlight_matrix.clear()\n```\n\n###### Parameters\n\n- - -\n\n##### get_orientation\n\nget_orientation() -> int\n\nRetrieve the current orientation of the Light Matrix.  \nCan be used with the following constants: `orientation.UP`, `orientation.LEFT`, `orientation.RIGHT`, `orientation.DOWN`\n\n###### Parameters\n\n- - -\n\n##### get_pixel\n\nget_pixel(x: int, y: int) -> int\n\nRetrieve the intensity of a specific pixel on the Light Matrix.\n\n```\nfrom hub import light_matrix\n\n# Show a heart \nlight_matrix.show_image(1)\n\n# Print the value of the center pixel's intensity \nprint(light_matrix.get_pixel(2, 2))\n```\n\n###### Parameters\n\n- - -\n\n###### x: int\n\nThe X value, range (0 - 4)\n\n###### y: int\n\nThe Y value, range (0 - 4)\n\n##### set_orientation\n\nset_orientation(top: int) -> int\n\nChange the orientation of the Light Matrix. All subsequent calls will use the new orientation.  \nCan be used with the following constants: `orientation.UP`, `orientation.LEFT`, `orientation.RIGHT`, `orientation.DOWN`\n\n###### Parameters\n\n- - -\n\n###### top: int\n\nThe side of the hub to be the top\n\n##### set_pixel\n\nset_pixel(x: int, y: int, intensity: int) -> None\n\nSets the brightness of one pixel (one of the 25 LEDs) on the Light Matrix.\n\n```\nfrom hub import light_matrix\n# Turn on the pixel in the center of the hub \nlight_matrix.set_pixel(2, 2, 100)\n```\n\n###### Parameters\n\n- - -\n\n###### x: int\n\nThe X value, range (0 - 4)\n\n###### y: int\n\nThe Y value, range (0 - 4)\n\n###### intensity: int\n\nHow bright to light up the pixel\n\n##### show\n\nshow(pixels: list[int]) -> None\n\nChange all the lights at the same time.\n\n```\nfrom hub import light_matrix\n# Update all pixels on Light Matrix using the show function \n\n# Create a list with 25 identical intensity values \npixels = [100] * 25 \n\n# Update all pixels to show same intensity \nlight_matrix.show(pixels)\n```\n\n###### Parameters\n\n- - -\n\n###### pixels: Iterable\n\nA list containing light intensity values for all 25 pixels.\n\n##### show_image\n\nshow_image(image: int) -> None\n\nDisplay one of the built in images on the display.\n\n```\nfrom hub import light_matrix\n# Update pixels to show an image on Light Matrix using the show_image function \n\n# Show a smiling face \nlight_matrix.show_image(light_matrix.IMAGE_HAPPY)\n```\n\n###### Parameters\n\n- - -\n\n###### image: int\n\nThe id of the image to show. The range of available images is 1 to 67. There are consts on the `light_matrix` module for these.\n\n##### write\n\nwrite(text: str, intensity: int = 100, time_per_character: int = 500) -> Awaitable\n\nDisplays text on the Light Matrix, one letter at a time, scrolling from right to left except if there is a single character to show which will not scroll\n\n```\nfrom hub import light_matrix\n# White a message to the hub \nlight_matrix.write(\"Hello, world!\")\n```\n\n###### Parameters\n\n- - -\n\n###### text: str\n\nThe text to display\n\n###### intensity: int\n\nHow bright to light up the pixel\n\n###### time_per_character: int\n\nHow long to show each character on the display\n\n##### Constants\n\n- - -\n\n##### hub.light_matrix Constants\n\n**IMAGE_HEART** = 1\n\n**IMAGE_HEART_SMALL** = 2\n\n**IMAGE_HAPPY** = 3\n\n**IMAGE_SMILE** = 4\n\n**IMAGE_SAD** = 5\n\n**IMAGE_CONFUSED** = 6\n\n**IMAGE_ANGRY** = 7\n\n**IMAGE_ASLEEP** = 8\n\n**IMAGE_SURPRISED** = 9\n\n**IMAGE_SILLY** = 10\n\n**IMAGE_FABULOUS** = 11\n\n**IMAGE_MEH** = 12\n\n**IMAGE_YES** = 13\n\n**IMAGE_NO** = 14\n\n**IMAGE_CLOCK12** = 15\n\n**IMAGE_CLOCK1** = 16\n\n**IMAGE_CLOCK2** = 17\n\n**IMAGE_CLOCK3** = 18\n\n**IMAGE_CLOCK4** = 19\n\n**IMAGE_CLOCK5** = 20\n\n**IMAGE_CLOCK6** = 21\n\n**IMAGE_CLOCK7** = 22\n\n**IMAGE_CLOCK8** = 23\n\n**IMAGE_CLOCK9** = 24\n\n**IMAGE_CLOCK10** = 25\n\n**IMAGE_CLOCK11** = 26\n\n**IMAGE_ARROW_N** = 27\n\n**IMAGE_ARROW_NE** = 28\n\n**IMAGE_ARROW_E** = 29\n\n**IMAGE_ARROW_SE** = 30\n\n**IMAGE_ARROW_S** = 31\n\n**IMAGE_ARROW_SW** = 32\n\n**IMAGE_ARROW_W** = 33\n\n**IMAGE_ARROW_NW** = 34\n\n**IMAGE_GO_RIGHT** = 35\n\n**IMAGE_GO_LEFT** = 36\n\n**IMAGE_GO_UP** = 37\n\n**IMAGE_GO_DOWN** = 38\n\n**IMAGE_TRIANGLE** = 39\n\n**IMAGE_TRIANGLE_LEFT** = 40\n\n**IMAGE_CHESSBOARD** = 41\n\n**IMAGE_DIAMOND** = 42\n\n**IMAGE_DIAMOND_SMALL** = 43\n\n**IMAGE_SQUARE** = 44\n\n**IMAGE_SQUARE_SMALL** = 45\n\n**IMAGE_RABBIT** = 46\n\n**IMAGE_COW** = 47\n\n**IMAGE_MUSIC_CROTCHET** = 48\n\n**IMAGE_MUSIC_QUAVER** = 49\n\n**IMAGE_MUSIC_QUAVERS** = 50\n\n**IMAGE_PITCHFORK** = 51\n\n**IMAGE_XMAS** = 52\n\n**IMAGE_PACMAN** = 53\n\n**IMAGE_TARGET** = 54\n\n**IMAGE_TSHIRT** = 55\n\n**IMAGE_ROLLERSKATE** = 56\n\n**IMAGE_DUCK** = 57\n\n**IMAGE_HOUSE** = 58\n\n**IMAGE_TORTOISE** = 59\n\n**IMAGE_BUTTERFLY** = 60\n\n**IMAGE_STICKFIGURE** = 61\n\n**IMAGE_GHOST** = 62\n\n**IMAGE_SWORD** = 63\n\n**IMAGE_GIRAFFE** = 64\n\n**IMAGE_SKULL** = 65\n\n**IMAGE_UMBRELLA** = 66\n\n**IMAGE_SNAKE** = 67\n\n#### Motion Sensor\n\nTo use the Motion Sensor module add the following import statement to your project:\n\n```\nfrom hub import motion_sensor\n```\n\nAll functions in the module should be called inside the `motion_sensor` module as a prefix like so:\n\n```\nmotion_sensor.up_face()\n```\n\n##### Functions\n\n##### acceleration\n\nacceleration(raw_unfiltered: bool) -> tuple[int, int, int]\n\nReturns a tuple containing x, y & z acceleration values as integers. The values are mili G, so 1 / 1000 G\n\n###### Parameters\n\n- - -\n\n###### raw_unfiltered: bool\n\nIf we want the data back raw and unfiltered\n\n##### angular_velocity\n\nangular_velocity(raw_unfiltered: bool) -> tuple[int, int, int]\n\nReturns a tuple containing x, y & z angular velocity values as integers. The values are decidegrees per second\n\n###### Parameters\n\n- - -\n\n###### raw_unfiltered: bool\n\nIf we want the data back raw and unfiltered\n\n##### gesture\n\ngesture() -> int\n\nReturns the gesture recognized.\n\nPossible values are:\n\n`motion_sensor.TAPPED`  \n`motion_sensor.DOUBLE_TAPPED`  \n`motion_sensor.SHAKEN`  \n`motion_sensor.FALLING`  \n`motion_sensor.UNKNOWN`\n\n###### Parameters\n\n- - -\n\n##### get_yaw_face\n\nget_yaw_face() -> int\n\nRetrieve the face of the hub that yaw is relative to.  \nIf you put the hub on a flat surface with the face returned pointing up, when you rotate the hub only the yaw will update  \n`motion_sensor.TOP` The SPIKE Prime hub face with the USB charging port.  \n`motion_sensor.FRONT` The SPIKE Prime hub face with the Light Matrix.  \n`motion_sensor.RIGHT` The right side of the SPIKE Prime hub when facing the front hub face.  \n`motion_sensor.BOTTOM` The side of the SPIKE Prime hub where the battery is.  \n`motion_sensor.BACK` The SPIKE Prime hub face where the speaker is.  \n`motion_sensor.LEFT` The left side of the SPIKE Prime hub when facing the front hub face.\n\n###### Parameters\n\n- - -\n\n##### quaternion\n\nquaternion() -> tuple[float, float, float, float]\n\nReturns the hub orientation quaternion as a tuple[w: float, x: float, y: float, z: float].\n\n###### Parameters\n\n- - -\n\n##### reset_tap_count\n\nreset_tap_count() -> None\n\nReset the tap count returned by the `tap_count` function\n\n###### Parameters\n\n- - -\n\n##### reset_yaw\n\nreset_yaw(angle: int) -> None\n\nChange the yaw angle offset.  \nThe angle set will be the new yaw value.\n\n###### Parameters\n\n- - -\n\n###### angle: int\n\n##### set_yaw_face\n\nset_yaw_face(up: int) -> bool\n\nChange what hub face is used as the yaw face.If you put the hub on a flat surface with this face pointing up, when you rotate the hub only the yaw will update\n\n###### Parameters\n\n- - -\n\n###### up: int\n\nThe hub face that should be set as the upwards facing hub face.  \nAvailable values are:\n\n`motion_sensor.TOP` The SPIKE Prime hub face with the USB charging port.  \n`motion_sensor.FRONT` The SPIKE Prime hub face with the Light Matrix.  \n`motion_sensor.RIGHT` The right side of the SPIKE Prime hub when facing the front hub face.  \n`motion_sensor.BOTTOM` The side of the SPIKE Prime hub where the battery is.  \n`motion_sensor.BACK` The SPIKE Prime hub face where the speaker is.  \n`motion_sensor.LEFT` The left side of the SPIKE Prime hub when facing the front hub face.\n\n##### stable\n\nstable() -> bool\n\nWhether or not the hub is resting flat.\n\n###### Parameters\n\n- - -\n\n##### tap_count\n\ntap_count() -> int\n\nReturns the number of taps recognized since the program started or last time `motion_sensor.reset_tap_count()` was called.\n\n###### Parameters\n\n- - -\n\n##### tilt_angles\n\ntilt_angles() -> tuple[int, int, int]\n\nReturns a tuple containing yaw pitch and roll values as integers. Values are decidegrees\n\n###### Parameters\n\n- - -\n\n##### up_face\n\nup_face() -> int\n\nReturns the Hub face that is currently facing up  \n`motion_sensor.TOP` The SPIKE Prime hub face with the USB charging port.  \n`motion_sensor.FRONT` The SPIKE Prime hub face with the Light Matrix.  \n`motion_sensor.RIGHT` The right side of the SPIKE Prime hub when facing the front hub face.  \n`motion_sensor.BOTTOM` The side of the SPIKE Prime hub where the battery is.  \n`motion_sensor.BACK` The SPIKE Prime hub face where the speaker is.  \n`motion_sensor.LEFT` The left side of the SPIKE Prime hub when facing the front hub face.\n\n###### Parameters\n\n- - -\n\n##### Constants\n\n- - -\n\n##### hub.motion_sensor Constants\n\n**TAPPED** = 0\n\n**DOUBLE_TAPPED** = 1\n\n**SHAKEN** = 2\n\n**FALLING** = 3\n\n**UNKNOWN** = -1\n\n**TOP** = 0  \nThe SPIKE Prime hub face with the Light Matrix.  \n**FRONT** = 1  \nThe SPIKE Prime hub face where the speaker is.  \n**RIGHT** = 2  \nThe right side of the SPIKE Prime hub when facing the front hub face.  \n**BOTTOM** = 3  \nThe side of the SPIKE Prime hub where the battery is.  \n**BACK** = 4  \nThe SPIKE Prime hub face with the USB charging port.  \n**LEFT** = 5  \nThe left side of the SPIKE Prime hub when facing the front hub face.\n\n#### Port\n\nThis module contains constants that enables easy access to the ports on the SPIKE Prime hub. Use the constants in all functions that takes a `port` parameter.\n\nTo use the Port module add the following import statement to your project:\n\n```\nfrom hub import port\n```\n\nAll functions in the module should be called inside the `port` module as a prefix like so:\n\n```\nport.A\n```\n\n##### Constants\n\n- - -\n\n##### hub.port Constants\n\n**A** = 0  \nThe Port that is labelled ‘A’ on the Hub.  \n**B** = 1  \nThe Port that is labelled ‘B’ on the Hub.  \n**C** = 2  \nThe Port that is labelled ‘C’ on the Hub.  \n**D** = 3  \nThe Port that is labelled ‘D’ on the Hub.  \n**E** = 4  \nThe Port that is labelled ‘E’ on the Hub.  \n**F** = 5  \nThe Port that is labelled ‘F’ on the Hub.\n\n#### Sound\n\nTo use the Sound module add the following import statement to your project:\n\n```\nfrom hub import sound\n```\n\nAll functions in the module should be called inside the `sound` module as a prefix like so:\n\n```\nsound.stop()\n```\n\n##### Functions\n\n##### beep\n\nbeep(freq: int = 440, duration: int = 500, volume: int = 100, *, attack: int = 0, decay: int = 0, sustain: int = 100, release: int = 0, transition: int = 10, waveform: int = WAVEFORM_SINE, channel: int = DEFAULT) -> Awaitable\n\nPlays a beep sound from the hub\n\n###### Parameters\n\n- - -\n\n###### freq: int\n\nThe frequency to play\n\n###### duration: int\n\nThe duration in milliseconds\n\n###### volume: int\n\nThe volume (0-100)\n\n###### Optional keyword arguments:\n\n###### attack: int\n\nThe time taken for initial run-up of level from nil to peak, beginning when the key is pressed.\n\n###### decay: int\n\nThe time taken for the subsequent run down from the attack level to the designated sustain level.\n\n###### sustain: int\n\nThe level during the main sequence of the sound's duration, until the key is released.\n\n###### release: int\n\nThe time taken for the level to decay from the sustain level to zero after the key is released\n\n###### transition: int\n\ntime in milliseconds to transition into the sound if something is already playing in the channel\n\n###### waveform: int\n\nThe synthesized waveform. Use one of the constants in the `hub.sound` module.\n\n###### channel: int\n\nThe desired channel to play on, options are `sound.DEFAULT` and `sound.ANY`\n\n##### stop\n\nstop() -> None\n\nStops all noise from the hub\n\n###### Parameters\n\n- - -\n\n##### volume\n\nvolume(volume: int) -> None\n\n###### Parameters\n\n- - -\n\n###### volume: int\n\nThe volume (0-100)\n\n##### Constants\n\n- - -\n\n##### hub.sound Constants\n\n**ANY** = -2\n\n**DEFAULT** = -1\n\n**WAVEFORM_SINE** = 1\n\n**WAVEFORM_SAWTOOTH** = 3\n\n**WAVEFORM_SQUARE** = 2\n\n**WAVEFORM_TRIANGLE** = 1\n\n#### Functions\n\n#### device_uuid\n\ndevice_uuid() -> str\n\nRetrieve the device id.\n\n##### Parameters\n\n- - -\n\n#### hardware_id\n\nhardware_id() -> str\n\nRetrieve the hardware id.\n\n##### Parameters\n\n- - -\n\n#### power_off\n\npower_off() -> int\n\nTurns off the hub.\n\n##### Parameters\n\n- - -\n\n#### temperature\n\ntemperature() -> int\n\nRetrieve the hub temperature. Measured in decidegrees celsius (d°C) which is 1 / 10 of a degree celsius (°C)\n\n##### Parameters\n\n- - -\n\n"
                },
                {
                    "text": "### Motor\n\nTo use a Motor add the following import statement to your project:\n\n```\nimport motor\n```\n\nAll functions in the module should be called inside the `motor` module as a prefix like so:\n\n```\nmotor.run(port.A, 1000)\n```\n\n#### Functions\n\n#### absolute_position\n\nabsolute_position(port: int) -> int\n\nGet the absolute position of a Motor\n\n##### Parameters\n\n- - -\n\n##### port: int\n\nA port from the `port` submodule in the `hub` module\n\n#### get_duty_cycle\n\nget_duty_cycle(port: int) -> int\n\nGet the pwm of a Motor\n\n##### Parameters\n\n- - -\n\n##### port: int\n\nA port from the `port` submodule in the `hub` module\n\n#### relative_position\n\nrelative_position(port: int) -> int\n\nGet the relative position of a Motor\n\n##### Parameters\n\n- - -\n\n##### port: int\n\nA port from the `port` submodule in the `hub` module\n\n#### reset_relative_position\n\nreset_relative_position(port: int, position: int) -> None\n\nChange the position used as the offset when using the `run_to_relative_position` function.\n\n##### Parameters\n\n- - -\n\n##### port: int\n\nA port from the `port` submodule in the `hub` module\n\n##### position: int\n\nThe degree of the motor\n\n#### run\n\nrun(port: int, velocity: int, *, acceleration: int = 1000) -> None\n\nStart a Motor at a constant speed\n\n```\nfrom hub import port\nimport motor, time\n\n# Start motor \nmotor.run(port.A, 1000)\n```\n\n##### Parameters\n\n- - -\n\n##### port: int\n\nA port from the `port` submodule in the `hub` module\n\n##### velocity: int\n\nThe velocity in degrees/sec\n\nValue ranges depends on motor type.\n\nSmall motor (essential): -660 to 660  \nMedium motor: -1110 to 1110  \nLarge motor: -1050 to 1050\n\n##### Optional keyword arguments:\n\n##### acceleration: int\n\nThe acceleration (deg/sec²) (1 - 10000)\n\n#### run_for_degrees\n\nrun_for_degrees(port: int, degrees: int, velocity: int, *, stop: int = BRAKE, acceleration: int = 1000, deceleration: int = 1000) -> Awaitable\n\nTurn a motor for a specific number of degrees  \nWhen awaited returns a status of the movement that corresponds to one of the following constants:\n\n`motor.READY`  \n`motor.RUNNING`  \n`motor.STALLED`  \n`motor.CANCELED`  \n`motor.ERROR`  \n`motor.DISCONNECTED`\n\n##### Parameters\n\n- - -\n\n##### port: int\n\nA port from the `port` submodule in the `hub` module\n\n##### degrees: int\n\nThe number of degrees\n\n##### velocity: int\n\nThe velocity in degrees/sec\n\nValue ranges depends on motor type.\n\nSmall motor (essential): -660 to 660  \nMedium motor: -1110 to 1110  \nLarge motor: -1050 to 1050\n\n##### Optional keyword arguments:\n\n##### stop: int\n\nThe behavior of the Motor after it has stopped. Use the constants in the `motor` module.\n\nPossible values are  \n`motor.COAST` to make the motor coast until a stop  \n`motor.BREAK` to brake and continue to brake after stop  \n`motor.HOLD` to tell the motor to hold it's position  \n`motor.CONTINUE` to tell the motor to keep running at whatever velocity it's running at until it gets another command  \n`motor.SMART_COAST` to make the motor brake until stop and then coast and compensate for inaccuracies in the next command  \n`motor.SMART_BRAKE` to make the motor brake and continue to brake after stop and compensate for inaccuracies in the next command\n\n##### acceleration: int\n\nThe acceleration (deg/sec²) (1 - 10000)\n\n##### deceleration: int\n\nThe deceleration (deg/sec²) (1 - 10000)\n\n#### run_for_time\n\nrun_for_time(port: int, duration: int, velocity: int, *, stop: int = BRAKE, acceleration: int = 1000, deceleration: int = 1000) -> Awaitable\n\nRun a Motor for a limited amount of time  \nWhen awaited returns a status of the movement that corresponds to one of the following constants:\n\n`motor.READY`  \n`motor.RUNNING`  \n`motor.STALLED`  \n`motor.ERROR`  \n`motor.DISCONNECTED`\n\n```\nfrom hub import port\nimport runloop\nimport motor\n\nasync def main():\n    # Run at 1000 velocity for 1 second \n    await motor.run_for_time(port.A, 1000, 1000)\n\n    # Run at 280 velocity for 1 second \n    await motor_pair.run_for_time(port.A, 1000, 280)\n\n    # Run at 280 velocity for 10 seconds with a slow deceleration \n    await motor_pair.run_for_time(port.A, 10000, 280, deceleration=10)\n\nrunloop.run(main())\n```\n\n##### Parameters\n\n- - -\n\n##### port: int\n\nA port from the `port` submodule in the `hub` module\n\n##### duration: int\n\nThe duration in milliseconds\n\n##### velocity: int\n\nThe velocity in degrees/sec\n\nValue ranges depends on motor type.\n\nSmall motor (essential): -660 to 660  \nMedium motor: -1110 to 1110  \nLarge motor: -1050 to 1050\n\n##### Optional keyword arguments:\n\n##### stop: int\n\nThe behavior of the Motor after it has stopped. Use the constants in the `motor` module.\n\nPossible values are  \n`motor.COAST` to make the motor coast until a stop  \n`motor.BREAK` to brake and continue to brake after stop  \n`motor.HOLD` to tell the motor to hold it's position  \n`motor.CONTINUE` to tell the motor to keep running at whatever velocity it's running at until it gets another command  \n`motor.SMART_COAST` to make the motor brake until stop and then coast and compensate for inaccuracies in the next command  \n`motor.SMART_BRAKE` to make the motor brake and continue to brake after stop and compensate for inaccuracies in the next command\n\n##### acceleration: int\n\nThe acceleration (deg/sec²) (1 - 10000)\n\n##### deceleration: int\n\nThe deceleration (deg/sec²) (1 - 10000)\n\n#### run_to_absolute_position\n\nrun_to_absolute_position(port: int, position: int, velocity: int, *, direction: int = motor.SHORTEST_PATH, stop: int = BRAKE, acceleration: int = 1000, deceleration: int = 1000) -> Awaitable\n\nTurn a motor to an absolute position.  \nWhen awaited returns a status of the movement that corresponds to one of the following constants:\n\n`motor.READY`  \n`motor.RUNNING`  \n`motor.STALLED`  \n`motor.CANCELED`  \n`motor.ERROR`  \n`motor.DISCONNECTED`\n\n##### Parameters\n\n- - -\n\n##### port: int\n\nA port from the `port` submodule in the `hub` module\n\n##### position: int\n\nThe degree of the motor\n\n##### velocity: int\n\nThe velocity in degrees/sec\n\nValue ranges depends on motor type.\n\nSmall motor (essential): -660 to 660  \nMedium motor: -1110 to 1110  \nLarge motor: -1050 to 1050\n\n##### Optional keyword arguments:\n\n##### direction: int\n\nThe direction to turn.  \nOptions are:\n\n`motor.CLOCKWISE`  \n`motor.COUNTERCLOCKWISE`  \n`motor.SHORTEST_PATH`  \n`motor.LONGEST_PATH`\n\n##### stop: int\n\nThe behavior of the Motor after it has stopped. Use the constants in the `motor` module.\n\nPossible values are  \n`motor.COAST` to make the motor coast until a stop  \n`motor.BREAK` to brake and continue to brake after stop  \n`motor.HOLD` to tell the motor to hold it's position  \n`motor.CONTINUE` to tell the motor to keep running at whatever velocity it's running at until it gets another command  \n`motor.SMART_COAST` to make the motor brake until stop and then coast and compensate for inaccuracies in the next command  \n`motor.SMART_BRAKE` to make the motor brake and continue to brake after stop and compensate for inaccuracies in the next command\n\n##### acceleration: int\n\nThe acceleration (deg/sec²) (1 - 10000)\n\n##### deceleration: int\n\nThe deceleration (deg/sec²) (1 - 10000)\n\n#### run_to_relative_position\n\nrun_to_relative_position(port: int, position: int, velocity: int, *, stop: int = BRAKE, acceleration: int = 1000, deceleration: int = 1000) -> Awaitable\n\nTurn a motor to a position relative to the current position.  \nWhen awaited returns a status of the movement that corresponds to one of the following constants:\n\n`motor.READY`  \n`motor.RUNNING`  \n`motor.STALLED`  \n`motor.CANCELED`  \n`motor.ERROR`  \n`motor.DISCONNECTED`\n\n##### Parameters\n\n- - -\n\n##### port: int\n\nA port from the `port` submodule in the `hub` module\n\n##### position: int\n\nThe degree of the motor\n\n##### velocity: int\n\nThe velocity in degrees/sec\n\nValue ranges depends on motor type.\n\nSmall motor (essential): -660 to 660  \nMedium motor: -1110 to 1110  \nLarge motor: -1050 to 1050\n\n##### Optional keyword arguments:\n\n##### stop: int\n\nThe behavior of the Motor after it has stopped. Use the constants in the `motor` module.\n\nPossible values are  \n`motor.COAST` to make the motor coast until a stop  \n`motor.BREAK` to brake and continue to brake after stop  \n`motor.HOLD` to tell the motor to hold it's position  \n`motor.CONTINUE` to tell the motor to keep running at whatever velocity it's running at until it gets another command  \n`motor.SMART_COAST` to make the motor brake until stop and then coast and compensate for inaccuracies in the next command  \n`motor.SMART_BRAKE` to make the motor brake and continue to brake after stop and compensate for inaccuracies in the next command\n\n##### acceleration: int\n\nThe acceleration (deg/sec²) (1 - 10000)\n\n##### deceleration: int\n\nThe deceleration (deg/sec²) (1 - 10000)\n\n#### set_duty_cycle\n\nset_duty_cycle(port: int, pwm: int) -> None\n\nStart a Motor with a specific pwm\n\n##### Parameters\n\n- - -\n\n##### port: int\n\nA port from the `port` submodule in the `hub` module\n\n##### pwm: int\n\nThe PWM value (-10000-10000)\n\n#### stop\n\nstop(port: int, *, stop: int = BRAKE) -> None\n\nStops a motor\n\n```\nfrom hub import port\nimport motor, time\n\n# Start motor \nmotor.run(port.A, 1000)\n\n# Wait for 2 seconds \ntime.sleep_ms(2000)\n\n# Stop motor \nmotor.stop(port.A)\n```\n\n##### Parameters\n\n- - -\n\n##### port: int\n\nA port from the `port` submodule in the `hub` module\n\n##### Optional keyword arguments:\n\n##### stop: int\n\nThe behavior of the Motor after it has stopped. Use the constants in the `motor` module.\n\nPossible values are  \n`motor.COAST` to make the motor coast until a stop  \n`motor.BREAK` to brake and continue to brake after stop  \n`motor.HOLD` to tell the motor to hold it's position  \n`motor.CONTINUE` to tell the motor to keep running at whatever velocity it's running at until it gets another command  \n`motor.SMART_COAST` to make the motor brake until stop and then coast and compensate for inaccuracies in the next command  \n`motor.SMART_BRAKE` to make the motor brake and continue to brake after stop and compensate for inaccuracies in the next command\n\n#### velocity\n\nvelocity(port: int) -> int\n\nGet the velocity (deg/sec) of a Motor\n\n##### Parameters\n\n- - -\n\n##### port: int\n\nA port from the `port` submodule in the `hub` module\n\n#### Constants\n\n- - -\n\n#### motor Constants\n\n**READY** = 0\n\n**RUNNING** = 1\n\n**STALLED** = 2\n\n**CANCELLED** = 3\n\n**ERROR** = 4\n\n**DISCONNECTED** = 5\n\n**COAST** = 0\n\n**BRAKE** = 1\n\n**HOLD** = 2\n\n**CONTINUE** = 3\n\n**SMART_COAST** = 4\n\n**SMART_BRAKE** = 5\n\n**CLOCKWISE** = 0\n\n**COUNTERCLOCKWISE** = 1\n\n**SHORTEST_PATH** = 2\n\n**LONGEST_PATH** = 3\n\n"
                },
                {
                    "text": "### Motor Pair\n\nThe `motor_pair` module is used to run motors in a synchronized fashion. This mode is optimal for creating drivebases where you'd want a pair of motors to start and stop at the same time.\n\nTo use the `motor_pair` module simply import the module like so:\n\n```\nimport motor_pair\n```\n\nAll functions in the module should be called inside the `motor_pair` module as a prefix like so:\n\n```\nmotor_pair.pair(motor_pair.PAIR_1, port.A, port.B)\n```\n\n#### Functions\n\n#### move\n\nmove(pair: int, steering: int, *, velocity: int = 360, acceleration: int = 1000) -> None\n\nMove a Motor Pair at a constant speed until a new command is given.\n\n```\nfrom hub import port\nimport runloop\nimport motor_pair\n\nasync def main():\n    # Pair motors on port A and B \n    motor_pair.pair(motor_pair.PAIR_1, port.A, port.B)\n\n    await runloop.sleep_ms(2000)\n\n    # Move straight at default velocity \n    motor_pair.move(motor_pair.PAIR_1, 0)\n\n    await runloop.sleep_ms(2000)\n\n    # Move straight at a specific velocity \n    motor_pair.move(motor_pair.PAIR_1, 0, velocity=280)\n\n    await runloop.sleep_ms(2000)\n\n    # Move straight at a specific velocity and acceleration \n    motor_pair.move(motor_pair.PAIR_1, 0, velocity=280, acceleration=100)\n\nrunloop.run(main())\n```\n\n##### Parameters\n\n- - -\n\n##### pair: int\n\nThe pair slot of the Motor Pair.\n\n##### steering: int\n\nThe steering (-100 to 100)\n\n##### Optional keyword arguments:\n\n##### velocity: int\n\nThe velocity in degrees/sec\n\nValue ranges depends on motor type.\n\nSmall motor (essential): -660 to 660  \nMedium motor: -1110 to 1110  \nLarge motor: -1050 to 1050\n\n##### acceleration: int\n\nThe acceleration (deg/sec²) (1 - 10000)\n\n#### move_for_degrees\n\nmove_for_degrees(pair: int, degrees: int, steering: int, *, velocity: int = 360, stop: int = motor.BRAKE, acceleration: int = 1000, deceleration: int = 1000) -> Awaitable\n\nMove a Motor Pair at a constant speed for a specific number of degrees.  \nWhen awaited returns a status of the movement that corresponds to one of the following constants from the motor module:\n\n`motor.READY`  \n`motor.RUNNING`  \n`motor.STALLED`  \n`motor.CANCELED`  \n`motor.ERROR`  \n`motor.DISCONNECTED`\n\n```\nfrom hub import port\nimport runloop\nimport motor_pair\n\nasync def main():\n    # Pair motors on port A and B \n    motor_pair.pair(motor_pair.PAIR_1, port.A, port.B)\n\n    # Move straight at default velocity for 90 degrees \n    await motor_pair.move_for_degrees(motor_pair.PAIR_1, 90, 0)\n\n    # Move straight at a specific velocity \n    await motor_pair.move_for_degrees(motor_pair.PAIR_1, 360, 0, velocity=280)\n\n    # Move straight at a specific velocity with a slow deceleration \n    await motor_pair.move_for_degrees(motor_pair.PAIR_1, 360, 0, velocity=280, deceleration=10)\n\nrunloop.run(main())\n```\n\n##### Parameters\n\n- - -\n\n##### pair: int\n\nThe pair slot of the Motor Pair.\n\n##### degrees: int\n\nThe number of degrees\n\n##### steering: int\n\nThe steering (-100 to 100)\n\n##### Optional keyword arguments:\n\n##### velocity: int\n\nThe velocity in degrees/sec\n\nValue ranges depends on motor type.\n\nSmall motor (essential): -660 to 660  \nMedium motor: -1110 to 1110  \nLarge motor: -1050 to 1050\n\n##### stop: int\n\nThe behavior of the Motor after it has stopped. Use the constants in the `motor` module.\n\nPossible values are  \n`motor.COAST` to make the motor coast until a stop  \n`motor.BREAK` to brake and continue to brake after stop  \n`motor.HOLD` to tell the motor to hold it's position  \n`motor.CONTINUE` to tell the motor to keep running at whatever velocity it's running at until it gets another command  \n`motor.SMART_COAST` to make the motor brake until stop and then coast and compensate for inaccuracies in the next command  \n`motor.SMART_BRAKE` to make the motor brake and continue to brake after stop and compensate for inaccuracies in the next command\n\n##### acceleration: int\n\nThe acceleration (deg/sec²) (1 - 10000)\n\n##### deceleration: int\n\nThe deceleration (deg/sec²) (1 - 10000)\n\n#### move_for_time\n\nmove_for_time(pair: int, duration: int, steering: int, *, velocity: int = 360, stop: int = motor.BRAKE, acceleration: int = 1000, deceleration: int = 1000) -> Awaitable\n\nMove a Motor Pair at a constant speed for a specific duration.  \nWhen awaited returns a status of the movement that corresponds to one of the following constants from the motor module:\n\n`motor.READY`  \n`motor.RUNNING`  \n`motor.STALLED`  \n`motor.CANCELED`  \n`motor.ERROR`  \n`motor.DISCONNECTED`\n\n```\nfrom hub import port\nimport runloop\nimport motor_pair\n\nasync def main():\n    # Pair motors on port A and B \n    motor_pair.pair(motor_pair.PAIR_1, port.A, port.B)\n\n    # Move straight at default velocity for 1 second \n    await motor_pair.move_for_time(motor_pair.PAIR_1, 1000, 0)\n\n    # Move straight at a specific velocity for 1 second \n    await motor_pair.move_for_time(motor_pair.PAIR_1, 1000, 0, velocity=280)\n\n    # Move straight at a specific velocity for 10 seconds with a slow deceleration \n    await motor_pair.move_for_time(motor_pair.PAIR_1, 10000, 0, velocity=280, deceleration=10)\n\nrunloop.run(main())\n```\n\n##### Parameters\n\n- - -\n\n##### pair: int\n\nThe pair slot of the Motor Pair.\n\n##### duration: int\n\nThe duration in milliseconds\n\n##### steering: int\n\nThe steering (-100 to 100)\n\n##### Optional keyword arguments:\n\n##### velocity: int\n\nThe velocity in degrees/sec\n\nValue ranges depends on motor type.\n\nSmall motor (essential): -660 to 660  \nMedium motor: -1110 to 1110  \nLarge motor: -1050 to 1050\n\n##### stop: int\n\nThe behavior of the Motor after it has stopped. Use the constants in the `motor` module.\n\nPossible values are  \n`motor.COAST` to make the motor coast until a stop  \n`motor.BREAK` to brake and continue to brake after stop  \n`motor.HOLD` to tell the motor to hold it's position  \n`motor.CONTINUE` to tell the motor to keep running at whatever velocity it's running at until it gets another command  \n`motor.SMART_COAST` to make the motor brake until stop and then coast and compensate for inaccuracies in the next command  \n`motor.SMART_BRAKE` to make the motor brake and continue to brake after stop and compensate for inaccuracies in the next command\n\n##### acceleration: int\n\nThe acceleration (deg/sec²) (1 - 10000)\n\n##### deceleration: int\n\nThe deceleration (deg/sec²) (1 - 10000)\n\n#### move_tank\n\nmove_tank(pair: int, left_velocity: int, right_velocity: int, *, acceleration: int = 1000) -> None\n\nPerform a tank move on a Motor Pair at a constant speed until a new command is given.\n\n```\nfrom hub import port\nimport runloop\nimport motor_pair\n\nasync def main():\n    # Pair motors on port A and B \n    motor_pair.pair(motor_pair.PAIR_1, port.A, port.B)\n\n    # Move straight at default velocity \n    motor_pair.move_tank(motor_pair.PAIR_1, 1000, 1000)\n\n    await runloop.sleep_ms(2000)\n\n    # Turn right \n    motor_pair.move_tank(motor_pair.PAIR_1, 0, 1000)\n\n    await runloop.sleep_ms(2000)\n\n    # Perform tank turn \n    motor_pair.move_tank(motor_pair.PAIR_1, 1000, -1000)\n\nrunloop.run(main())\n```\n\n##### Parameters\n\n- - -\n\n##### pair: int\n\nThe pair slot of the Motor Pair.\n\n##### left_velocity: int\n\nThe velocity (deg/sec) of the left motor.\n\n##### right_velocity: int\n\nThe velocity (deg/sec) of the right motor.\n\n##### Optional keyword arguments:\n\n##### acceleration: int\n\nThe acceleration (deg/sec²) (1 - 10000)\n\n#### move_tank_for_degrees\n\nmove_tank_for_degrees(pair: int, degrees: int, left_velocity: int, right_velocity: int, *, stop: int = motor.BRAKE, acceleration: int = 1000, deceleration: int = 1000) -> Awaitable\n\nPerform a tank move on a Motor Pair at a constant speed until a new command is given.  \nWhen awaited returns a status of the movement that corresponds to one of the following constants from the motor module:\n\n`motor.READY`  \n`motor.RUNNING`  \n`motor.STALLED`  \n`motor.CANCELED`  \n`motor.ERROR`  \n`motor.DISCONNECTED`\n\n```\nfrom hub import port\nimport runloop\nimport motor_pair\n\nasync def main():\n    # Pair motors on port A and B \n    motor_pair.pair(motor_pair.PAIR_1, port.A, port.B)\n\n    # Move straight at default velocity for 360 degrees \n    await motor_pair.move_tank_for_degrees(motor_pair.PAIR_1, 360, 1000, 1000)\n\n    # Turn right for 180 degrees \n    await motor_pair.move_tank_for_degrees(motor_pair.PAIR_1, 180, 0, 1000)\n\n    # Perform tank turn for 720 degrees \n    await motor_pair.move_tank_for_degrees(motor_pair.PAIR_1, 720, 1000, -1000)\n\nrunloop.run(main())\n```\n\n##### Parameters\n\n- - -\n\n##### pair: int\n\nThe pair slot of the Motor Pair.\n\n##### degrees: int\n\nThe number of degrees\n\n##### left_velocity: int\n\nThe velocity (deg/sec) of the left motor.\n\n##### right_velocity: int\n\nThe velocity (deg/sec) of the right motor.\n\n##### Optional keyword arguments:\n\n##### stop: int\n\nThe behavior of the Motor after it has stopped. Use the constants in the `motor` module.\n\nPossible values are  \n`motor.COAST` to make the motor coast until a stop  \n`motor.BREAK` to brake and continue to brake after stop  \n`motor.HOLD` to tell the motor to hold it's position  \n`motor.CONTINUE` to tell the motor to keep running at whatever velocity it's running at until it gets another command  \n`motor.SMART_COAST` to make the motor brake until stop and then coast and compensate for inaccuracies in the next command  \n`motor.SMART_BRAKE` to make the motor brake and continue to brake after stop and compensate for inaccuracies in the next command\n\n##### acceleration: int\n\nThe acceleration (deg/sec²) (1 - 10000)\n\n##### deceleration: int\n\nThe deceleration (deg/sec²) (1 - 10000)\n\n#### move_tank_for_time\n\nmove_tank_for_time(pair: int, left_velocity: int, right_velocity: int, duration: int, *, stop: int = motor.BRAKE, acceleration: int = 1000, deceleration: int = 1000) -> Awaitable\n\nPerform a tank move on a Motor Pair at a constant speed for a specific amount of time.  \nWhen awaited returns a status of the movement that corresponds to one of the following constants from the motor module:\n\n`motor.READY`  \n`motor.RUNNING`  \n`motor.STALLED`  \n`motor.CANCELED`  \n`motor.ERROR`  \n`motor.DISCONNECTED`\n\n```\nfrom hub import port\nimport runloop\nimport motor_pair\n\nasync def main():\n    # Pair motors on port A and B \n    motor_pair.pair(motor_pair.PAIR_1, port.A, port.B)\n\n    # Move straight at default velocity for 1 second \n    await motor_pair.move_tank_for_time(motor_pair.PAIR_1, 1000, 1000, 1000)\n\n    # Turn right for 3 seconds \n    await motor_pair.move_tank_for_time(motor_pair.PAIR_1, 0, 1000, 3000)\n\n    # Perform tank turn for 2 seconds \n    await motor_pair.move_tank_for_time(motor_pair.PAIR_1, 1000, -1000, 2000)\n\nrunloop.run(main())\n```\n\n##### Parameters\n\n- - -\n\n##### pair: int\n\nThe pair slot of the Motor Pair.\n\n##### duration: int\n\nThe duration in milliseconds\n\n##### left_velocity: int\n\nThe velocity (deg/sec) of the left motor.\n\n##### right_velocity: int\n\nThe velocity (deg/sec) of the right motor.\n\n##### Optional keyword arguments:\n\n##### stop: int\n\nThe behavior of the Motor after it has stopped. Use the constants in the `motor` module.\n\nPossible values are  \n`motor.COAST` to make the motor coast until a stop  \n`motor.BREAK` to brake and continue to brake after stop  \n`motor.HOLD` to tell the motor to hold it's position  \n`motor.CONTINUE` to tell the motor to keep running at whatever velocity it's running at until it gets another command  \n`motor.SMART_COAST` to make the motor brake until stop and then coast and compensate for inaccuracies in the next command  \n`motor.SMART_BRAKE` to make the motor brake and continue to brake after stop and compensate for inaccuracies in the next command\n\n##### acceleration: int\n\nThe acceleration (deg/sec²) (1 - 10000)\n\n##### deceleration: int\n\nThe deceleration (deg/sec²) (1 - 10000)\n\n#### pair\n\npair(pair: int, left_motor: int, right_motor: int) -> None\n\npair two motors (`left_motor` & `right_motor`) and store the paired motors in `pair`.  \nUse `pair` in all subsequent `motor_pair` related function calls.\n\n```\nimport motor_pair\nfrom hub import port\n\nmotor_pair.pair(motor_pair.PAIR_1, port.A, port.B)\n```\n\n##### Parameters\n\n- - -\n\n##### pair: int\n\nThe pair slot of the Motor Pair.\n\n##### left_motor: int\n\nThe port of the left motor. Use the `port` submodule in the `hub` module.\n\n##### right_motor: int\n\nThe port of the right motor. Use the `port` submodule in the `hub` module.\n\n#### stop\n\nstop(pair: int, *, stop: int = motor.BRAKE) -> None\n\nStops a Motor Pair.\n\n```\nimport motor_pair\n\nmotor_pair.stop(motor_pair.PAIR_1)\n```\n\n##### Parameters\n\n- - -\n\n##### pair: int\n\nThe pair slot of the Motor Pair.\n\n##### Optional keyword arguments:\n\n##### stop: int\n\nThe behavior of the Motor after it has stopped. Use the constants in the `motor` module.\n\nPossible values are  \n`motor.COAST` to make the motor coast until a stop  \n`motor.BREAK` to brake and continue to brake after stop  \n`motor.HOLD` to tell the motor to hold it's position  \n`motor.CONTINUE` to tell the motor to keep running at whatever velocity it's running at until it gets another command  \n`motor.SMART_COAST` to make the motor brake until stop and then coast and compensate for inaccuracies in the next command  \n`motor.SMART_BRAKE` to make the motor brake and continue to brake after stop and compensate for inaccuracies in the next command\n\n#### unpair\n\nunpair(pair: int) -> None\n\nUnpair a Motor Pair.\n\n```\nimport motor_pair\n\nmotor_pair.unpair(motor_pair.PAIR_1)\n```\n\n##### Parameters\n\n- - -\n\n##### pair: int\n\nThe pair slot of the Motor Pair.\n\n#### Constants\n\n- - -\n\n#### motor_pair Constants\n\n**PAIR_1** = 0  \nFirst Motor Pair  \n**PAIR_2** = 1  \nSecond Motor Pair  \n**PAIR_3** = 2  \nThird Motor Pair\n\n"
                },
                {
                    "text": "### Orientation\n\nThe `orientation` module contains all the orientation constants to use with the `light_matrix` module.\n\nTo use the orientation module add the following import statement to your project:\n\n```\nimport orientation\n```\n\n#### Constants\n\n- - -\n\n#### orientation Constants\n\n**UP** = 0\n\n**RIGHT** = 1\n\n**DOWN** = 2\n\n**LEFT** = 3\n\n"
                },
                {
                    "text": "### Runloop\n\nThe `runloop` module contains all functions and constants to use the Runloop.\n\nTo use the Runloop module add the following import statement to your project:\n\n```\nimport runloop\n```\n\nAll functions in the module should be called inside the `runloop` module as a prefix like so:\n\n```\nrunloop.run(some_async_function())\n```\n\n#### Functions\n\n#### run\n\nrun(*functions: Awaitable) -> None\n\nStart any number of parallel `async` functions. This is the function you should use to create programs with a similar structure to Word Blocks.\n\n##### Parameters\n\n- - -\n\n##### *functions: awaitable\n\nThe functions to run\n\n#### sleep_ms\n\nsleep_ms(duration: int) -> Awaitable\n\nPause the execution of the application for any amount of milliseconds.\n\n```\nfrom hub import light_matrix\nimport runloop\n\nasync def main():\n    light_matrix.write(\"Hi!\")\n    # Wait for ten seconds \n    await runloop.sleep_ms(10000)\n    light_matrix.write(\"Are you still here?\")\n\nrunloop.run(main())\n```\n\n##### Parameters\n\n- - -\n\n##### duration: int\n\nThe duration in milliseconds\n\n#### until\n\nuntil(function: Callable[[], bool], timeout: int = 0) -> Awaitable\n\nReturns an awaitable that will return when the condition in the function or lambda passed is `True` or when it times out\n\n```\nimport color_sensor\nimport color\nfrom hub import port\nimport runloop\n\ndef is_color_red():\n    return color_sensor.color(port.A) is color.RED\n\nasync def main():\n    # Wait until Color Sensor sees red \n    await runloop.until(is_color_red)\n    print(\"Red!\")\n\nrunloop.run(main())\n```\n\n##### Parameters\n\n- - -\n\n##### function: Callable[[], bool]\n\nA callable with no parameters that returns either `True` or `False`.  \nCallable is anything that can be called, so a `def` or a `lambda`\n\n##### timeout: int\n\nA timeout for the function in milliseconds.  \nIf the callable does not return `True` within the timeout, the `until` still resolves after the timeout.  \n0 means no timeout, in that case it will not resolve until the callable returns `True`"
                }
            ]
            const result = await legoapis.bulkWrite(
                legoapisToInsert.map((api) => ({
                    insertOne: {
                        document: api
                    }
                }))
            );
            console.log("legoapis result:", result);
        }

        // legosnippet
        {
            const legosnippets = db.collection('legosnippet');
            await legosnippets.deleteMany({});
            const legosnippetsToInsert = [
                {
                    _id: "1000",
                    description: 'spin motor for 360 degrees to turn right',
                    python_code:
                        `
from hub import port
import runloop
import motor_pair

async def main():
    # Pair motors on port A and B
    motor_pair.pair(motor_pair.PAIR_1, port.A, port.B)

    # spin motor for 360 degrees to turn right
    motor_pair.move_tank_for_degrees(motor_pair.PAIR_1, 360, 100, -100)

runloop.run(main())
`
                },
                {
                    _id: "1002",
                    description: 'pin motor for 360 degrees to turn left',
                    python_code:
                        `
from hub import port
import runloop
import motor_pair

async def main():
    # Pair motors on port A and B
    motor_pair.pair(motor_pair.PAIR_1, port.A, port.B)

    # spin motor for 360 degrees to turn left
    motor_pair.move_tank_for_degrees(motor_pair.PAIR_1, 360, -100, 100)

runloop.run(main())
`
                }
            ]
            const result = await legosnippets.bulkWrite(
                legosnippetsToInsert.map((api) => ({
                    insertOne: {
                        document: api
                    }
                }))
            );
            console.log("legosnippets result:", result);
        }

        // legoinfo
        {
            const legoinfos = db.collection('legoinfo');
            await legoinfos.deleteMany({});
            const legoinfosToInsert = [
                {
                    "text": "### Introduction to Python\n\nPython is a popular text-based coding language that is excellent for beginners because it’s concise and easy-to-read. It’s also useful for programmers because it’s applicable to web and software development, as well as scientific applications like data analysis and machine learning.\n\nThis **Getting Started** section introduces the basics of using Python with LEGO® Education SPIKE™ Prime. It contains chapters where you’ll:\n\n**Introduction to Python**\n\n1.  Learn to use the _Code Editor_ in the LEGO® Education SPIKE™ App to write Python code.\n\n**Hello, World!**\n\n2.  Write a message on the Light Matrix of the SPIKE Prime Hub.\n\n**Comments in Python**\n\n3.  Learn how comments can help you describe draft and finished programs.\n\n**Controlling Motors**\n\n4.  Define and start _asynchronous functions_ to control motors.\n\n**Variables**\n\n5.  Control two motors with _local_ and _global_ variables.\n\n**The Power of Random**\n\n6.  Discover ways to create fun and unpredictable programs that control the light on the Hub.\n\n**Sensor Control**\n\n7.  Control a motor using the Force Sensor. Then learn ways to use the Console to _debug_ your program.\n\n**Sensor Conditions**\n\n8.  Use _logical expressions_ to react to different conditions. Then learn to run different parts of your code together to react to multiple conditions.\n\n**Next Steps**\n\n9.  Get suggestions for additional resources to learn more about using Python with SPIKE Prime.\n\n#### Python Syntax\n\nWhen learning a text programming language, the first step is to understand its _syntax_. This language syntax prescribes the rules for writing _statements_ (lines of code), and how to indicate _code blocks_ that consist of multiple statements.\n\nIn Python, each statement begins with a level of _indentation_ and ends with a _line break_. Indentation is the number of spaces before a statement. Lines with the same number of spaces have the same _indentation level_ and belong to the same code block. The SPIKE App uses 4 spaces for each indentation level.\n\nYou write code in the _Code Editor_, which has features to help you write it correctly. For example, when you start a new code block, like a _function_ or `if` statement, the Editor indents the next line with four extra spaces. Also, it numbers each line to make it easier to navigate your code.\n\n_Syntax highlighting_ in the Code Editor shows _comments_, _keywords_, text, and numbers in different colors so the code is easier to read. In the code below, the comment on the first line is green, the keywords `print`, `if`, and `True` are blue, the text `'LEGO'` is magenta, and the number `123` is orange.\n\n```\n# This is a comment.\nprint('LEGO')\nif True:\n    print(123)\n```\n\nThe code above is an _example program_, which you’ll find throughout the **Getting Started** chapters. Each example has a Copy icon in the top right corner:\n\nPress this icon to copy the whole example program. Then right-click or long-press the Code Editor and choose Paste from the menu to paste the code. You can also press `CTRL`+`V` on Windows or `Command`+`V` on Mac.\n\n#### SPIKE Prime Modules\n\nTo control the SPIKE Prime Hub, sensors, and motors, you’ll need the SPIKE Prime _modules_. Modules are used to organize related code. There’s one for each SPIKE Prime component, e.g., the `motor` module contains the code to control the motors. To use the functionality of a module, first _import_ it with the `import` statement:\n\n```\nimport motor\n```\n\nImport the modules you need once at the beginning of your Python program. See the **SPIKE Prime Modules** section of this User Guide for more on the modules and their functionality.\n\n#### MicroPython\n\nThe SPIKE Prime Hub is a small computer called a microcontroller, which has limited memory and processing power. Since the full Python programming language would use too much memory, the Hub runs _MicroPython_, a highly optimized version of the Python language that can run on microcontrollers. The modules to control the SPIKE Prime Hub, sensors, and motors are also highly optimized by using optimized _data types_.\n\nYou’ve seen that the Code Editor shows text and numbers in different colors – because they’re different data types. Python further distinguishes between whole numbers and decimals. Whole numbers are also known as _integers_, or type `int`, which is optimized in MicroPython. Decimals use the unoptimized `float` type, so the SPIKE Prime modules avoid this data type. This means you have to stick to whole numbers or use different _units_ to describe decimals. For half a second, you can use 500 milliseconds instead of 0.5 seconds.\n\n#### Challenge\n\nCan you copy some of the example code in this chapter and paste it to the Code Editor?"
                },
                {
                    "text": "### Hello, World!\n\nIt’s a tradition when learning a new programming language to create a “Hello, World!” program. You’re going to write “Hello, World!” on the Light Matrix of the SPIKE Prime Hub. First, make sure your SPIKE Prime Hub is turned on and connected to the SPIKE App. Then follow these four steps:\n\n1.  Make sure the Code Editor is empty by deleting any existing code.\n2.  Press the Copy icon in the top right corner of the example below to copy the code.\n3.  Right-click or long-press the Code Editor and then choose Paste from the menu to paste the code.\n4.  Press the Play button to run the program.\n\n```\nfrom hub import light_matrix\n\nlight_matrix.write('Hello, World!')\n```\n\nYou’ll see the text “Hello, World!” scrolling across the Light Matrix.\n\nLet’s look at the code line by line.\n\nThe first line imports the `light_matrix` module from the `hub` module, which controls the Light Matrix of the Hub. After importing a module, you can use its various functions.\n\nThe final line _calls_ the `write()` _function_ from the `light_matrix` module to write “Hello, World!” on the Light Matrix.\n\n#### Define a Function\n\nIn the previous example, you used the `write()` function. A function is a block of code that performs a task when you call it. You define a function with the `def` keyword, followed by the function name, parentheses, and a colon. The _body_ of the function is indented and contains all the code that runs when you call the function. You call a function by writing the function name and parentheses. Make sure to _unindent_ the function call, otherwise it’s part of the function body.\n\nThe example below defines the `hello()` function, which writes “Hello, World!” on the Light Matrix, and calls the function once. Try to run the example code. Remember to first delete any existing code from the Code Editor, before you copy, paste, and run the code.\n\n```\nfrom hub import light_matrix\n\ndef hello():\n    light_matrix.write('Hello, World!')\n\nhello()\n```\n\n#### Add a Parameter\n\nIn the example above, the `hello()` function has no _parameters_, so it writes “Hello World” on the Light Matrix each time you call it. To make it more dynamic, add a parameter name inside the parentheses of the function definition. The code block in the function body can then use this parameter to do something different based on its value. An example of this is the `write()` function, which has one required parameter: the text to write on the Light Matrix.\n\nThe example below adds a `name` parameter to the `hello()` function, which then writes `'Hello, ' + name + '!'` on the Light Matrix. Notice the `+` _operator_, which lets you add pieces of text together. Text is also known as a _string_, or type `str`. It is surrounded by either single (`'`) or double (`\"`) straight quotation marks, using the same type around a given text string. The updated `hello()` function has one required parameter of type `str`, so you can _pass_ the string `'World'` as an _argument_ when you call it to write “Hello, World!” on the Light Matrix.\n\nTry running the example code. Don’t forget to delete any existing code from the Code Editor before you copy, paste, and run your new code.\n\n```\nfrom hub import light_matrix\n\ndef hello(name):\n    light_matrix.write('Hello, ' + name + '!')\n\nhello('World')\n```\n\nYou’ll see the text “Hello, World!” scrolling across the Light Matrix once again.\n\n#### Challenge\n\nCan you change the code so the Hub greets _you_ instead of the world?"
                },
                {
                    "text": "### Comments in Python\n\nIt’s easier to use code when you know what it should do. You can describe this in everyday language by adding comments. Comments aren’t part of the code that runs on the Hub, so they don’t influence its functionality.\n\nThe `#` character marks the start of a comment. You’d usually place a comment before the code it describes, but you can also place short comments after a code statement.\n\n```\n# This is a comment.\nfrom hub import light_matrix\n# This is another comment.\n```\n\nSometimes part of your program doesn’t behave like you want it to. In such cases, it’s useful to _comment out_ parts of the code by adding the `#` character at the start of the line. These lines then become comments and no longer run as a part of your program. Commenting out parts of a program can help you _debug_ or find and correct the problem. To quickly comment out multiple lines of code, select them and then press `CTRL`+`/` on Windows or `Command`+`/` on Mac. To change multiple comments back to code, select them and press the same key combination.\n\n```\n# The next line is commented out:\n# light_matrix.write('Hello, World!')\n```\n\nYou can also use comments to describe your code before writing the working code. That’s called _pseudocode_ and it can help you describe in everyday language what your program should do. The example below uses comments as pseudocode for a blinking-eyes animation on the Light Matrix.\n\n```\n# Show a happy face with eyes on the Light Matrix.\n# Wait for some time.\n# Show a smile without eyes on the Light Matrix.\n# Wait for a short time.\n# Show the first image again on the Light Matrix.\n```\n\n#### Blinking Eyes Program\n\nThis program will show a face with blinking eyes on the Light Matrix of the Hub. Copy the code below and paste it into the Code Editor. Then run the program. As always, delete any existing code from the Code Editor before pasting the new code.\n\nWhen you run this program, you’ll see that the smiley face blinks after a second. The program calls the `show_image()` function from the `hub.light_matrix` module to show an image on the Light Matrix. The program uses the `sleep_ms()` function from the `time` module to add delays for a number of milliseconds between different images. In the code, each comment describes what the next line of code should do.\n\n```\nimport time\n\nfrom hub import light_matrix\n\n# Show a happy face on the Light Matrix.\nlight_matrix.show_image(light_matrix.IMAGE_HAPPY)\n\n# Wait for one second.\ntime.sleep_ms(1000)\n\n# Show a smile on the Light Matrix.\nlight_matrix.show_image(light_matrix.IMAGE_SMILE)\n\n# Wait for 0.2 seconds.\ntime.sleep_ms(200)\n\n# Show a happy face on the Light Matrix.\nlight_matrix.show_image(light_matrix.IMAGE_HAPPY)\n```\n\n#### “WET” or “DRY”?\n\nAlthough commenting every line of code is tempting, the result is that you’ll _Write Everything Twice_. These _WET_ comments don’t help readers if the code is self-explanatory. Instead, follow the _DRY_ principle and _Don’t Repeat Yourself_.\n\nIn the example below, the lines of code that blink the eyes are inside the new `blink()` function. The program then calls the function three times, so the eyes blink three times. Notice that this time, the comments describe only the main parts of the code to help readers understand what that code should do.\n\n```\nimport time\n\nfrom hub import light_matrix\n\n# This function blinks the eyes.\ndef blink():\n    light_matrix.show_image(light_matrix.IMAGE_HAPPY)\n    time.sleep_ms(1000)\n    light_matrix.show_image(light_matrix.IMAGE_SMILE)\n    time.sleep_ms(200)\n    light_matrix.show_image(light_matrix.IMAGE_HAPPY)\n\n# Blink three times.\nblink()\nblink()\nblink()\n```\n\n#### Challenge\n\nCan you change the code to keep the eyes open longer each time they blink?"
                },
                {
                    "text": "### Controlling Motors\n\nYou’re ready to connect and use the motors. Connect a motor to port A and try the program below.\n\n```\nimport motor\nfrom hub import port\n\n# Run a motor on port A for 360 degrees at 720 degrees per second.\nmotor.run_for_degrees(port.A,360,720)\n```\n\nYou should see the motor run 360 degrees (one complete rotation) at 720 degrees (two rotations) per second.\n\nLet’s examine the code line by line.\n\nThe first line imports the `motor` module that controls the motors.\n\nThe second line imports `port` from the `hub` module, which holds the value for each port. You can write `port.A` for port A, `port.B` for port B, and so on to specify the port(s) you want.\n\nThe final line calls the `run_for_degrees()` function with three _arguments_:\n\n1.  The first parameter specifies which motor to run, using the port value.\n2.  The second parameter specifies the number of degrees to run.\n3.  The third parameter specifies at what velocity to run the motor, in degrees per second.\n\n#### Multiple Motors\n\nNow connect a second motor to port B and try the program below.\n\n```\nimport motor\nfrom hub import port\n\n# Run two motors on ports A and B for 360 degrees at 720 degrees per second.\n# The motors run at the same time.\nmotor.run_for_degrees(port.A, 360, 720)\nmotor.run_for_degrees(port.B, 360, 720)\n```\n\nNotice that both motors run 360 degrees (one rotation) at 720 degrees per second, starting and ending at the same time. Since the two motor statements are on separate lines, you might expect them to run one by one. However, they run at the same time because the `run_for_degrees()` is an _awaitable_ function. That means you _can_ wait for it to complete, but you don’t have to. By default, the program immediately continues to the next line of code while the awaitable code runs to completion in the background. This makes it possible to run multiple commands at the same time.\n\n#### Run Loop, Async, and Await\n\nTo effectively use awaitable code with the flexibility to run commands either concurrently or sequentially, you must run your code in an _asynchronous function_ using a _run loop_. The `runloop` module controls the run loop on the Hub, and lets you run asynchronous functions with its `run()` function. An asynchronous function, also known as a _coroutine_, is an awaitable that uses the `async` keyword before the function definition. The convention is to name the coroutine containing your main program `main()`. The code below shows the general structure of a program using a run loop.\n\n```\nimport runloop\n\nasync def main():\n    # Write your program here.\n\nrunloop.run(main())\n```\n\nIn the body of a coroutine, you can use the `await` keyword before calling an awaitable command. This pauses the coroutine until the command completes. Without the keyword, the program immediately continues to the next line of code in the coroutine. You can still use regular (not awaitable) code inside the coroutine. However, doing so will always pause or _block_ the whole program until the command completes.\n\nThe program below defines the `main()` coroutine, which uses the `await` keyword before the two `run_for_degrees()` function calls. It uses the `run()` function from the `runloop` module to run the `main()` coroutine on the final line of code.\n\n```\nimport motor\nimport runloop\nfrom hub import port\n\nasync def main():\n    # Run two motors on ports A and B for 360 degrees at 720 degrees per second.\n    # The motors run after each other.\n    await motor.run_for_degrees(port.A, 360, 720)\n    await motor.run_for_degrees(port.B, 360,720)\n\nrunloop.run(main())\n```\n\nTry the sample code. You should see that both motors run 360 degrees (one rotation) at 720 degrees per second, one at a time.\n\n#### Challenge\n\nCan you change the code to run both motors at the same time again?"
                },
                {
                    "text": "### Variables\n\nSometimes, you find yourself writing the same number again and again. For example, the motor commands in the previous chapter ran for the same number of degrees at the same velocity each time. In cases like this, using variables makes changing multiple commands easier.\n\nYou create a variable by writing the variable name, followed by a single `=` sign, and the initial value for the variable. If you want to change the value of an existing variable, you use the exact same format to _assign_ a new value to it.\n\nConnect motors to ports A and B and try the program below.\n\n```\nimport motor\nimport runloop\nfrom hub import port\n\nasync def main():\n    # Create a variable `velocity` with a value of 720.\n    velocity = 720\n\n    # Run two motors on ports A and B for 360 degrees.\n    # Use the value of the `velocity` variable for the motor velocity.\n    await motor.run_for_degrees(port.A,360, velocity)\n    await motor.run_for_degrees(port.B, 360, velocity)\n\nrunloop.run(main())\n```\n\nAs in the previous chapter, you’ll see both motors run 360 degrees (one rotation) at 720 degrees per second, one at a time. The example here creates a `velocity` variable and uses it in the `run_for_degrees()` function calls. Because we used a variable, it’s easy to change the motor velocity for all the motor commands. Try changing the value of the `velocity` variable and run the program again.\n\n#### Variable Scope\n\nIt’s important to understand that it matters _where_ a variable is created. When you create a variable inside a function, it’s only available to that function. This is called a _local_ variable. If you want to use a variable across different functions in your program, you must create the variable outside the functions, for example underneath your `import` statements. This is called a _global_ variable.\n\n```\nimport motor\nimport runloop\nfrom hub import port\n\n# Create a global variable `velocity` with a value of 720.\nvelocity = 720\n\nasync def main():\n    # Create a local variable `degrees` with a value of 360.\n    degrees = 360\n\n    # Run two motors on ports A and B.\n    # Use the value of the `degrees` variable for the number of degrees.\n    # Use the value of the `velocity` variable for the motor velocity.\n    await motor.run_for_degrees(port.A, degrees, velocity)\n    await motor.run_for_degrees(port.B, degrees, velocity)\n\nrunloop.run(main())\n```\n\nOnce again, you’ll see both motors run 360 degrees (one rotation) at 720 degrees per second, one at a time. This time the `velocity` variable has global _scope_ and a new `degrees` variable has local scope. You can use the global `velocity` variable both inside and outside of the `main()` function, but you can only use the local `degrees` variable inside the `main()` function where it is defined.\n\nIt can be tempting to define all your variables at the top of your program so they have global scope, because then you can conveniently use them in your whole program. However, this also means that the value of those variables can be changed from _anywhere_ in your program, with undesired side effects. Instead, _tightly scope_ your variables, so only the parts of your program that need to use and change them have access.\n\n#### Variables in Loops\n\nIn Python, the simplest way to repeat some code a number of times is to use a `for` loop with the built-in `range()` function. For example, to repeat something four times, you write `for i in range(4):` followed by the code you want to run four times. You can think of `range(4)` as the _tuple_ `(0, 1, 2, 3)`. Tuples and _lists_ such as `[ 1, 2, 3 ]` are _iterables_. The `for` loop takes an iterable and _loops over_ its values until it reaches the end.\n\nWhen a `for` loop _iterates_ over a tuple or list, it changes the value of a local variable on each iteration. So far, you’ve explicitly created variables and assigned them a value using the `=` sign. In a `for` loop, the name of the local variable is defined after the `for` keyword, in this case `i`. Each time the loop runs, the value of this local variable `i` changes. It will be `0` the first time the loop runs and `3` the last time it runs, corresponding to the values in `(0, 1, 2, 3)`.\n\nThe next example uses a `for` loop to change the global `velocity` variable four times to run the motor on port A with a different velocity each time. To enable changing the global variable `velocity` in the _local context_ of the `main()` function, you need to use the `global` keyword before `velocity` at the start of the function body.\n\n```\nimport motor\nimport runloop\nfrom hub import port\n\n# Create a global variable `velocity` with a value of 450.\nvelocity = 450\n\nasync def main():\n    # Use the `global` keyword to enable changing `velocity` here.\n    global velocity\n\n    # Create a local variable `degrees` with a value of 360.\n    degrees = 360\n\n    # The `for` loop creates a local variable `i` and repeats 4 times.\n    # The values of the `i` variable are 0, 1, 2, and 3.\n    for i in range(4):\n # Change the global variable `velocity` by adding `i`*90 each time.\n # The values of the `velocity` variable are 450, 540, 720, and 990.\n velocity = velocity + i*90\n await motor.run_for_degrees(port.A, degrees, velocity)\n\n    # The value of the `velocity` variable outside the `for` loop is 990.\n    await motor.run_for_degrees(port.B, degrees, velocity)\n\nrunloop.run(main())\n```\n\nRun the example code. You’ll see the motor on port A run 360 degrees four times, at four different velocities, faster each time. The final time, the motor on port B runs 360 degrees once at 990 degrees per second.\n\n#### Challenge\n\nCan you change the code so the motor on port A runs a different number of degrees each time?"
                },
                {
                    "text": "### The Power of Random\n\nSometimes, the best program is an unpredictable one. When you don’t know what a program will do next, it seems more alive. To achieve this result, add some randomness.\n\nThe program below will set the Power Button light on the SPIKE Prime Hub to ten different colors, with a random delay between each color change.\n\n```\nimport random\nimport time\nfrom hub import light\n\nfor color in range(11):\n    # Set the light to the current color.\n    light.color(light.POWER, color)\n\n    # Keep the light on for 0.5 to 1.5 seconds.\n    sleep_time = random.randint(500,1500)\n    time.sleep_ms(sleep_time)\n```\n\nEach color is represented by a different number. The `for` loop iterates over `range(11)` and assigns the value to the `color` variable. It will be `0` (black) which turns the light off the first time the loop runs and `10` (white) in the last iteration. Notice that this program imports the `random` module, which contains several functions to add randomness.\n\nThis example uses the `randint()` function, with a `start` value of 500 and a `stop` value of 1500. With these arguments, the function _returns_ a number between 500 and 1500 to add some variation to the sleep time. However, the colors will always light up in the same order even if you run the program several times. Luckily, the `random` module has some other functions to add even more randomness to the program.\n\n#### Loop Forever\n\nYou can also use a `while` loop to repeat something forever instead of a specific number of times. In Python, the simplest way to create such a loop is to write `while True:` followed by the code you want to run forever. The next example uses a `while True` loop to run a little disco show forever or until you stop the program.\n\n```\nimport random\nimport time\nfrom hub import light\n\nwhile True:\n    # Generate a random number between 1 and 9.\n    random_color = random.randint(1, 9)\n\n    # Set the light to the random color.\n    light.color(light.POWER, random_color)\n\n    # Keep the light on for 0.5 to 1.5 seconds.\n    sleep_time = random.randint(500, 1500)\n    time.sleep_ms(sleep_time)\n```\n\nNotice that the Power Button lights up in random colors, with a random delay between each color change. The example uses the `randint()` function again to generate a number between 1 and 9 (both included), which corresponds to the different color numbers excluding black (`0`) and white (`10`).\n\n#### Lists and Constants\n\nIf you want the light show to only include certain colors, you can put them in a _list_ and then choose a random color from it. You create a new list like a variable, first writing the list name, then the `=` sign, and finally the values inside square brackets, separated with commas. For a simple list with at least two _items_, write `my_list = [ 1, 2 ]`. You can add as many values as you want.\n\nAs you’ve seen in the previous examples, each color is represented by a different number. You use this number to set the light to that color, for example, number `9` will set the light to red. However, using numbers for colors can make it harder for other readers to know what your code will do. You could add comments to describe each value, but a better way is to make variables for each color. The `color` module has a variable `RED` so you can write `color.RED` instead of the number `9` in your code. (A variable listed with all capital letters is a _constant_, which means you shouldn’t change it.)\n\nThe example below imports the `color` module and uses some of the color constants to create the list `colors`. This time, the `randint()` function determines how many times the `for` loop runs, and the light turns white at the end of this little random light show.\n\n```\nimport random\nimport time\nimport color\nfrom hub import light\n\n# Create a list with some different light colors.\ncolors = [color.RED, color.GREEN, color.BLUE, color.YELLOW ]\n\n# Change the light five to ten times.\ntimes = random.randint(5, 10)\n\nfor i in range(times):\n    # Choose a random color from the list of colors.\n    random_color = random.choice(colors)\n\n    # Set the light to the random color.\n    light.color(light.POWER, random_color)\n\n    # Keep the light on for 0.5 to 1.5 seconds.\n    sleep_time = random.randint(500, 1500)\n    time.sleep_ms(sleep_time)\n\n# Set the light to white.\nlight.color(light.POWER, color.WHITE)\n```\n\nYou’ll see the Power Button light change to a random color from the list, for a random number of times, with a random delay between each color change. The example uses the `choice()` function to pick a random color from the `colors` list.\n\n#### Challenge\n\nCan you change the code so there are different colors in the `colors` list?"
                },
                {
                    "text": "### Sensor Control\n\nIn the previous chapters, you tried using variables and random numbers to control the motors and the light. Now you’ll use a sensor value to control a motor.\n\nConnect a motor to port A and a Force Sensor to port B and try the program below.\n\n```\nimport force_sensor\nimport motor\nfrom hub import port\n\n# Store the force of the Force Sensor in a variable.\nforce = force_sensor.force(port.B)\n\n# Print the variable to the Console.\nprint(force)\n\n# Run the motor and use the variable to set the velocity.\nmotor.run(port.A, force)\n```\n\nPress the Force Sensor while the program is running. That didn’t do much, right? Luckily, the example uses the built-in `print()` function to write the `force` variable to the Console, so that you can easily see what went wrong.\n\n#### The Console\n\nSometimes your program doesn’t do what you expect it to do. You can use the `print()` function to _debug_ your program when that happens. The `print()` function writes whatever you pass as the argument to the Console window below the Code Editor, in this case the force of the Force Sensor. Run the program again and notice the value that appears in the Console.\n\nYou’ll see a single number in the console, and unless you were pressing the Force Sensor when you started the program, that number is `0`. Running a motor at 0 degrees per second doesn’t do much, so the problem is that the program only checks the sensor value once at the start of the program. To update the motor velocity based on the force for as long as the program runs, you’ll need to use the `while True` loop again.\n\nThe Console also displays error messages when something goes wrong while running your program. One common error happens when you run a program to control a motor or read a sensor that isn’t connected. Disconnect the Force Sensor and run the same program one last time. You’ll see an error in the Console informing you that there was a problem, what the problem was, and on what line of code it happened.\n\n#### Fix the Bugs\n\nThe Console helped you find two bugs. Reconnect the Force Sensor to port B to fix the second bug and then run the program below that fixes the first bug by _wrapping_ the code in a `while True` loop.\n\n```\nimport force_sensor\nimport motor\nfrom hub import port\n\nwhile True:\n    # Store the force of the Force Sensor in a variable.\n    force = force_sensor.force(port.B)\n\n    # Print the variable to the Console.\n    print(force)\n\n    # Run the motor and use the variable to set the speed.\n    motor.run(port.A, force)\n```\n\nPress the Force Sensor while the program is running. You’ll see the motor speeding up or slowing down depending on how hard you press the Force Sensor. You’ll also see a lot of variable values written in the Console. The Force Sensor force is measured in decinewtons (dN) and since the maximum force it can measure is 10 newtons, the maximum value in dN is 100. Running a motor at 100 degrees per second still isn’t very fast!\n\n#### Function Return Values\n\nInstead of storing the value of the Force Sensor in a variable, you can also define a function that _returns_ this value. Separating the different parts of your program this way makes it easier to organize your code and fix bugs if they happen.\n\nThe next program defines a `motor_velocity()` function that returns the desired motor velocity based on the force of the Force Sensor instead of using a variable.\n\n```\nimport force_sensor\nimport motor\nfrom hub import port\n\n# This function returns the desired motor velocity.\ndef motor_velocity():\n    # The velocity is five times the force of the Force Sensor.\n    return force_sensor.force(port.B) * 5\n\nwhile True:\n    # Run the motor like before.\n    # Use the `motor_velocity()` function return value for velocity.\n    motor.run(port.A, motor_velocity())\n```\n\nPress the Force Sensor while the program is running. You’ll see the motor speeding up or slowing down depending on how hard you press the Force Sensor. The `motor_velocity()` function multiplies the force value by 5, so the velocity will be between 0 and 500 degrees per second.\n\n#### Challenge\n\nCan you change the code to run the motor at 1000 degrees per second when the Force Sensor is fully pressed?"
                },
                {
                    "text": "### Sensor Conditions\n\nYou’ve used the sensor value to control a motor directly, but it’s also possible to change the _flow_ of the program using sensor _conditions_ and an `if`statement. The `if` statement is an essential part of programming and the simplest way to control the flow of your program.\n\nYou create an `if` statement by writing `if` followed by a logical expression and a colon. Logical expressions are basically yes / no questions, such as “Is the color red?” or “Is the button pressed?” If the answer to the question is “yes,” the expression is evaluated to be `True` and otherwise it is `False`. These are the two _Boolean_ values used in Python, and are of type `bool`. All the lines of code with the same indentation level after the `if` statement are part of the code block that runs if the expression is `True`.\n\nFor an example, connect a Color Sensor to port A and run the program below.\n\n```\nfrom hub import port, sound\nimport color\nimport color_sensor\nimport runloop\n\nasync def main():\n    while True:\n # Check if the red color is detected.\n if color_sensor.color(port.A) == color.RED:\n # If red is detected start a very long beep.\n sound.beep(440, 1000000, 100)\n # Pause the program while red is detected.\n while color_sensor.color(port.A) == color.RED:\n     await runloop.sleep_ms(1)\n # Stop the sound when red is no longer detected.\n sound.stop()\n\nrunloop.run(main())\n```\n\nWave a red LEGO® brick in front of the Color Sensor while the program is running. You’ll hear a beep when the red color is detected, which stops when the red color is no longer detected. The example uses an `if` statement to check if the color detected by the Color Sensor is red. It does this using the _equality operator_ `==` with the Color Sensor color value on the left and the `color.RED` constant on the right. (Note that there are two `=` signs vs. the single `=` sign you used to assign values to variables.) If the Color Sensor color value is the same as the `color.RED` constant, the condition is `True` and the code block after the `if` statement runs.\n\nIt’s important to wrap the code in a `while True` loop. Otherwise, the Color Sensor only checks the color for a split second when the program starts. So far, you used the `while` loop with the `True` constant to repeat code forever. You can also use the `while` loop with a logical expression to repeat code only as long as that expression evaluates to `True`. The example above uses the same condition as the `if` statement in the inner `while` loop, to continue playing the beep while the red color is detected. When the condition is no longer `True`, the Hub _exits_ the `while` loop and runs the next line of code to stop the sound.\n\nInside the inner `while` loop, notice the `sleep_ms()` function from the `runloop` module. This function pauses the `main()` coroutine for a number of milliseconds in a _non-blocking_ way. Because it uses the `await` keyword, other tasks can run while that coroutine is paused. In the example, the pause is one millisecond. This may seem like very little time, but it’s enough for the Hub to run many coroutines concurrently. The `sleep_ms()` function from the `time` module, which you used in earlier chapters, pauses the program in a _blocking_ way. This means that it pauses the entire program and not just the code block where you call it.\n\n#### What Else?\n\nYou can add more than one condition by extending the `if` statement with an `elif` statement that checks another condition. You can add as many of these as you need, and they follow the same syntax as the `if` statement. The `elif` should be on the same indentation level as the first `if` statement, and the `elif` keyword is followed by a logical expression and a colon. Indent the next line(s) of code that should run when this condition is `True`.\n\nSometimes, none of the conditions in the `if` and `elif` statements are `True`. In this case, you can run some code by adding an `else` statement without any condition. This runs when all the previous conditions are `False`.\n\nFor example, the program below adds an `elif` and `else` statement to also beep if the left button is pressed.\n\n```\nfrom hub import button, port, sound\nimport color\nimport color_sensor\nimport runloop\n\n# This function returns `True` if the Color Sensor detects red.\ndef red_detected():\n    return color_sensor.color(port.A) == color.RED\n\n# This function returns `True` if the left button is pressed.\ndef left_pressed():\n    return button.pressed(button.LEFT) > 0\n\nasync def main():\n    while True:\n if red_detected():\n # If red is detected start a very long beep.\n sound.beep(440, 1000000, 100)\n # Wait until red is no longer detected.\n while red_detected():\n     await runloop.sleep_ms(1)\n elif left_pressed():\n # If the left button is pressed make a short beep.\n sound.beep(880, 200, 100)\n # Wait until the left button is released.\n while left_pressed():\n     await runloop.sleep_ms(1)\n else:\n # Otherwise, stop the sound.\n sound.stop()\n\nrunloop.run(main())\n```\n\nWave a red LEGO brick in front of the Color Sensor and press the left button on the Hub while the program is running. You’ll hear a beep for as long as the red color is detected, and a short beep each time the left button is pressed.\n\nThe example defines two functions to do the logic tests and return the result. The `red_detected()` function checks if the color detected by the Color Sensor is red and returns the result `True` or `False`. The `left_pressed()` function uses the `pressed()` function from the `hub.button` module and uses the `>` operator to check if the value is _greater than_ `0` and returns the result.\n\nThe code in the `if` statement here is largely the same as the first example, but now it uses the `red_detected()` function in two places instead of repeating the condition for the `if` and `while` statements. The `elif` statement uses the `left_pressed()` function to check if the left button on the Hub is pressed for more than `0` milliseconds.\n\nNote that the `elif` statement only runs when the condition of the first `if` statement is `False`. Therefore, pressing the button while the Color Sensor detects something red has no effect. You should carefully consider the order of your `if` and `elif` conditions and check the most important ones first. The `else` statement stops the sound if neither condition is `True`.\n\n#### Multiple Conditions\n\nWhen you use `if`/`elif`/`else` statements to test for multiple conditions, only one of the blocks will run. These conditions are _mutually exclusive_. You’ve seen that while the color red was detected, pressing the left button had no effect. To truly check multiple conditions, you must check them at the same time. Like adding several stacks of Word Blocks, in Python you can run multiple coroutines with the `run()` function from the `runloop` module. Until now, you’ve called it with the `main()` coroutine as its only argument, but it’s possible to pass multiple coroutines as comma-separated arguments.\n\nFor example, the program below divides the code that checks the detected color and the pressed button into two coroutines. The `run()` function on the final line of code starts both coroutines at the same time.\n\n```\nfrom hub import button, port, sound\nimport color\nimport color_sensor\nimport runloop\n\n# This function returns `True` if the Color Sensor detects red.\ndef red_detected():\n    return color_sensor.color(port.A) == color.RED\n\n# This function returns `True` if the left button is pressed.\ndef left_pressed():\n    return button.pressed(button.LEFT) > 0\n\n# This coroutine continuously checks if the Color Sensor detects red.\nasync def check_color():\n    while True:\n # Wait until red is detected.\n while not red_detected():\n await runloop.sleep_ms(1)\n # When it's detected start a very long beep.\n sound.beep(440, 1000000, 100)\n # Wait until red is no longer detected.\n while red_detected():\n await runloop.sleep_ms(1)\n # When red is no longer detected stop the sound.\n sound.stop()\n\n# This coroutine continuously checks if the left button is pressed.\nasync def check_button():\n    while True:\n # Wait until the left button is pressed.\n while not left_pressed():\n await runloop.sleep_ms(1)\n # When it's pressed make a short beep.\n sound.beep(880, 200, 100)\n # Wait until the left button is released.\n while left_pressed():\n await runloop.sleep_ms(1)\n\n# Run both coroutines.\nrunloop.run(check_color(), check_button())\n```\n\nWave a red LEGO brick in front of the Color Sensor and press the left button on the Hub while the program is running. Like before, you’ll hear a beep for as long as the red color is detected, and a short beep each time the left button is pressed. This time, it’s possible to press the left button and hear a beep while the red color is detected because both functions run at the same time.\n\nWhen you create your own coroutines, remember that:\n\n*   Your coroutines should at least `await` one command.\n*   When you use a _tight_ `while` loop, use `await runloop.sleep_ms(1)` inside the loop to give other coroutines a chance to start and run.\n\n#### Challenge\n\nCan you change the code to detect a different color than red?"
                },
                {
                    "text": "### Next Steps\n\nIn the previous chapters, you\n\n*   learned the basics of using Python with SPIKE Prime, and how to use the Hub Light Matrix, Light, Speaker, and Buttons, as well as the motors, Color Sensor, and Force Sensor.\n*   became familiar with regular and asynchronous functions, local and global variables, and data types such as `int`, `bool`, `str`, `tuple`, and `list`.\n*   used `for` and `while` loops, as well as `if`/`elif`/`else` statements to control the flow of your program.\n*   learned how to use comments in your code, and when things go wrong, how to debug the program.\n\nThis is quite an achievement – you can be proud of yourself!\n\nThere are additional resources you can access to learn even more about using Python with SPIKE Prime.\n\n#### Python User Guide\n\nThis **Getting Started** section has barely scratched the surface of what’s possible with Python and SPIKE Prime. Explore these two other sections of the Python User Guide.\n\n1.  **Examples** Find example programs that show how to use Python to solve various tasks. Copy and try them, then modify them to suit your needs.\n2.  **SPIKE Prime Modules** Find documentation of all the functions and variables in the SPIKE Prime modules with short examples of how to use them.\n\n#### Python Lessons\n\nOn the LEGOeducation.com/lessons website, select the product **SPIKE™ Prime with Python**. You’ll find several unit plans with 6–8 lessons each (available in English only). These 50+ lessons cover a wide range of topics, from debugging to sensor control, and from simple games to data and math functions. Discover the many possibilities and become an expert using Python with SPIKE Prime.\n\n#### Challenge\n\nCreate a new Python project and get coding!"
                }
            ]
            const result = await legoinfos.bulkWrite(
                legoinfosToInsert.map((api) => ({
                    insertOne: {
                        document: api
                    }
                }))
            );
            console.log("legoinfos result:", result);
        }


    } catch (err) {
        console.error(err);
    } finally {
        await client.close();
        console.log('Disconnected from MongoDB');
    }
}


main().catch(console.error);